<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端工具函数utils.js]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0utils-js.html</url>
    <content type="text"><![CDATA[这个utils.js主要用于layui中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536/* * 扩展一个utils模块 * */layui.define([&apos;layer&apos;, &apos;table&apos;, &apos;form&apos;, &apos;laydate&apos;, &apos;laytpl&apos;, &apos;admin&apos;, &apos;view&apos;], function (exports) &#123; //提示：模块也可以依赖其它模块，如：layui.define(&apos;layer&apos;, callback); var $ = layui.$, layer = layui.layer, form = layui.form, table = layui.table, laydate = layui.laydate, laytpl = layui.laytpl, admin = layui.admin, view = layui.view, setter = layui.setter, baseUrl = setter.baseUrl; var utils = &#123; // 测试 hello: function (str) &#123; console.log(&apos;Hello &apos; + (str || &quot;xuqi&apos;s m-utils&quot;)); &#125;, /*时间转换*/ checkTime: function checkTime(i) &#123; if (i &lt; 10) &#123; i = &apos;0&apos; + i; &#125; return i; &#125;, formatTime: function formatTime(date) &#123; var getFullYear = this.checkTime(date.getFullYear()); var getMonth = this.checkTime(date.getMonth() + 1); var getDate = this.checkTime(date.getDate()); var getHours = this.checkTime(date.getHours()); var getMinutes = this.checkTime(date.getMinutes()); var getSeconds = this.checkTime(date.getSeconds()); return getFullYear + &quot;-&quot; + getMonth + &quot;-&quot; + getDate + &quot; &quot; + getHours + &quot;:&quot; + getMinutes + &quot;:&quot; + getSeconds; &#125;, /* 开发中的提示 */ coding: function (btn) &#123; var btn_dom = btn; if (!btn) &#123; btn_dom = &apos;.js-btn-coding&apos;; &#125; $(btn_dom).on(&apos;click&apos;, function () &#123; layer.alert(&apos;维护中，需官方授权开放&apos;); return false; &#125;); &#125;, codingAlert: function () &#123; layer.alert(&apos;维护中，需官方授权开放&apos;); return false; &#125;, /* 配置table */ setTableOption: function (dataName, method) &#123; var method = method || &apos;get&apos;; table.set(&#123; method: method, request: &#123; pageName: &apos;curpage&apos;, //页码的参数名称，默认：page limitName: &apos;pagesize&apos; //每页数据量的参数名，默认：limit &#125;, response: &#123; statusName: &apos;code&apos;, //数据状态的字段名称，默认：code statusCode: 200, //成功的状态码，默认：0 msgName: &apos;message&apos;, //状态信息的字段名称，默认：msg countName: &apos;count&apos;, //数据总数的字段名称，默认：count dataName: dataName //数据列表的字段名称，默认：data &#125; &#125;) &#125;, /*类型验证*/ checkStr: function (str, type) &#123; switch (type) &#123; case &apos;phone&apos;: //手机号码 return (/^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str)); case &apos;tel&apos;: //座机 return (/^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str)); case &apos;card&apos;: //身份证 return (/^\d&#123;15&#125;|\d&#123;18&#125;$/.test(str)); case &apos;pwd&apos;: //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return (/^[a-zA-Z]\w&#123;5,17&#125;$/.test(str)); case &apos;postal&apos;: //邮政编码 return (/[1-9]\d&#123;5&#125;(?!\d)/.test(str)); case &apos;QQ&apos;: //QQ号 return (/^[1-9][0-9]&#123;4,9&#125;$/.test(str)); case &apos;email&apos;: //邮箱 return (/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str)); case &apos;money&apos;: //金额(小数点2位) return (/(^[1-9]([0-9]+)?(\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\.[0-9]([0-9])?$)/.test(str) // return (/^\d*(?:\.\d&#123;0,2&#125;)?$/.test(str) ); case &apos;URL&apos;: //网址 return (/(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/.test(str)); case &apos;IP&apos;: //IP return (/((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str)); case &apos;date&apos;: //日期时间 return (/^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/.test(str) || /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/.test(str)); case &apos;number&apos;: //数字 return (/^[0-9]$/.test(str)); case &apos;integers&apos;: //数字 return (/^-?[1-9]\d*$/.test(str)); case &apos;integer&apos;: //非负整数 return (/^(0|[1-9]\d*)$/.test(str)); case &apos;integer5&apos;: //非负整数1-5 return (/^[0-5]$/.test(str)); case &apos;english&apos;: //英文 return (/^[a-zA-Z]+$/.test(str)); case &apos;chinese&apos;: //中文 return (/^[\u4E00-\u9FA5]+$/.test(str)); case &apos;lower&apos;: //小写 return (/^[a-z]+$/.test(str)); case &apos;upper&apos;: //大写 return (/^[A-Z]+$/.test(str)); case &apos;HTML&apos;: //HTML标记 return (/&lt;(&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|[^&apos;&quot;&gt;])*&gt;/.test(str)); default: return true; &#125; &#125;, positiveInteger: function () &#123; form.verify(&#123; positiveInteger: [ /^(0|[1-9]\d*)$/, &apos;请输入正整数&apos; ] &#125;); &#125;, money: function () &#123; form.verify(&#123; money: [ /(^[1-9]([0-9]+)?(\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\.[0-9]([0-9])?$)/, &apos;金额只能保留小数点后两位&apos; ] &#125;); &#125;, /*保留两位小数*/ returnFloat: function returnFloat(value) &#123; // var value=Math.round(parseFloat(value)*100)/100; var xsd = value.toString().split(&quot;.&quot;); if (xsd.length == 1) &#123; value = value.toString() + &quot;.00&quot;; return value; &#125; if (xsd.length &gt; 1) &#123; if (xsd[1].length &lt; 2) &#123; value = value.toString() + &quot;0&quot;; &#125; else &#123; value = xsd[0] + &apos;.&apos; + xsd[1].substr(0, 2); &#125; return value; &#125; &#125;, /*选择时间范围*/ laydate: function (dom) &#123; laydate.render(&#123; elem: dom, //指定元素 range: true, //或 range: &apos;~&apos; 来自定义分割字符 done: function (value, date, endDate) &#123; var start_date, end_date; var $start = $(dom).siblings(&apos;.js-time-start&apos;); var $end = $(dom).siblings(&apos;.js-time-end&apos;); // console.log(value); if (value) &#123; start_date = date.year + &apos;-&apos; + utils.checkTime(date.month) + &apos;-&apos; + utils.checkTime(date.date); end_date = endDate.year + &apos;-&apos; + utils.checkTime(endDate.month) + &apos;-&apos; + utils.checkTime(endDate.date); &#125; else &#123; start_date = &apos;&apos;; end_date = &apos;&apos;; &#125; console.log(&#123; &apos;start_date&apos;: start_date, &apos;end_date&apos;: end_date &#125;); $start.val(start_date); $end.val(end_date); &#125; &#125;); &#125;, /* 可能废弃，layer有photos方法可替换 */ showImg: function showImg($this, td_title_index) &#123; let idx = td_title_index; let type = typeof (idx); // let this_id = &apos;#&apos; + $this.attr(&apos;id&apos;); let this_class = &apos;.&apos; + $this.attr(&apos;class&apos;); let td_img_index = $this.closest(&apos;td&apos;).index(); let th_img_title = $this.closest(&apos;.layui-table-box&apos;).find(&apos;.layui-table-header thead&gt;tr&gt;th&apos;).eq(td_img_index).text(); let content_img = $this.find(&apos;img&apos;); let th_index_title = &apos;&apos;; console.log(type) if (idx &amp;&amp; type === &apos;number&apos;) &#123; th_index_title = $this.closest(&apos;tr&apos;).find(&apos;td&apos;).eq(idx).text(); th_img_title = th_index_title + &apos;的&apos; + th_img_title; &#125; else if (idx &amp;&amp; type === &apos;string&apos;) &#123; th_index_title = $this.closest(&apos;tr&apos;).find(&apos;td[data-field=&quot;&apos; + idx + &apos;&quot;]&apos;).text(); th_img_title = th_index_title + &apos;的&apos; + th_img_title; &#125; // console.log(idx, this_str); layer.open(&#123; type: 1, shadeClose: true, scrollbar: false, title: th_img_title || &apos;图像&apos;, content: $this, //捕获的元素，注意：最好该指定的元素要存放在body最外层，否则可能被其它的相对元素所影响 // area: [&apos;500px&apos;, &apos;542px&apos;], success: function () &#123; $(&apos;body&apos;).off(&apos;click&apos;, this_class); &#125;, end: function () &#123; $(&apos;body&apos;).on(&apos;click&apos;, this_class, function () &#123; var $this = $(this); console.log(idx); utils.showImg($this, idx); &#125;); &#125; &#125;); &#125;, /*展示图片新方法*/ photos: function (domClass) &#123; var imgParent = $(&apos;img&apos;).parent(); if (domClass) &#123; imgParent = $(`.$&#123;domClass&#125;`); &#125; imgParent.each(function (i) &#123; let id = $(this).attr(&apos;id&apos;); if (id) &#123; layer.photos(&#123; photos: `#$&#123;id&#125;`, anim: 5 &#125;) &#125; &#125;); &#125;, /* 关闭layer的iframe窗口 */ closeIframe: function () &#123; var index = parent.layer.getFrameIndex(window.name); parent.layer.close(index) &#125;, /* 获取url参数，返回值为object */ args: function (params) &#123; var a = &#123;&#125;; params = params || location.search; if (!params) return &#123;&#125;; params = decodeURI(params); params.replace(/(?:^\?|&amp;)([^=&amp;]+)(?:\=)([^=&amp;]+)(?=&amp;|$)/g, function (m, k, v) &#123; a[k] = v; &#125;); return a; &#125;, /* 重置form表单方法，不会重置部分input的值 */ reset: function ($reset) &#123; var $input = $($reset).closest(&apos;.layui-form&apos;).find(&quot;:input&quot;); // var $select = $($reset).closest(&apos;.layui-form&apos;).find(&quot;select&quot;); // console.log($input.not(&quot;:button, :submit, :reset,:disabled,[readonly]&quot;)); $input.not(&quot;:button, :submit, :reset,:disabled,[readonly]&quot;).val(&quot;&quot;); $input.not(&quot;:disabled,[readonly]&quot;).removeAttr(&quot;checked&quot;); &#125;, /*模板渲染*/ tplRender: function (tplId, viewId, tplData, callback) &#123; var $tplId, $viewId; if (typeof (tplId) === &apos;string&apos;) &#123; if (tplId.indexOf(&apos;#&apos;) === -1) &#123; $tplId = document.getElementById(tplId); &#125; else &#123; $tplId = document.getElementById(tplId.substring(1)); &#125; &#125; if (typeof (viewId) === &apos;string&apos;) &#123; if (viewId.indexOf(&apos;#&apos;) === -1) &#123; $viewId = document.getElementById(viewId); &#125; else &#123; $viewId = document.getElementById(viewId.substring(1)); &#125; &#125; var getTpl, view; if ($tplId) &#123; getTpl = $tplId.innerHTML; &#125; else &#123; getTpl = tplId.innerHTML; &#125; if ($viewId) &#123; view = $viewId; &#125; else &#123; view = viewId; &#125; var data = tplData || true; // console.log(data) laytpl(getTpl).render( data, function (html) &#123; view.innerHTML = html; callback &amp;&amp; callback(); &#125; ); &#125;, /* 给没有http开头的图片修改成完整的图片地址 */ ossUrl: &apos;http://garment-scm.oss-cn-hangzhou.aliyuncs.com/&apos;, imgUrl: function (img, size, url) &#123; let newUrl = img; let baseUrl = url || this.ossUrl; let urlAfter = size || &apos;&apos;; if (size === &apos;sm&apos;) &#123; urlAfter = &apos;?x-oss-process=image/resize,w_132,h_132&apos;; &#125; if (size === &apos;lg&apos;) &#123; urlAfter = &apos;?x-oss-process=image/resize,w_800,h_800&apos;; &#125; if (img.indexOf(&apos;http&apos;) === -1) &#123; // newUrl=baseUrl+newUrl; newUrl = baseUrl + newUrl + urlAfter; &#125; return newUrl; &#125;, /* 给没有http开头的网址添加成完整的网址 */ httpUrl: function (url) &#123; let newUrl = url; if (url.indexOf(&apos;http&apos;) === -1) &#123; newUrl = &apos;http://&apos; + newUrl; &#125; return newUrl; &#125;, strSubstr(str, index) &#123; let num = this.ossUrl.length; let idx = index || 0; let newStr = str.substr(idx, num) &#125;, /* 把图片名称组成的字符串转换成数组Array */ strToArr: function (str, separator) &#123; var splitStr = separator || &apos;|&apos;; var Arr = []; if (str) &#123; Arr = str.split(splitStr) &#125; return Arr; &#125;, /* 把图片名称组成的数组Array转换成字符串String */ arrToStr: function (arr, separator) &#123; var splitStr = separator || &apos;|&apos;; var Str = arr.join(splitStr); if (arr.length === 1) &#123; Str = arr[0] &#125; if (arr.length === 0) &#123; Str = &apos;&apos; &#125; return Str; &#125;, /*数组去重*/ arrNoRep: function (arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr.indexOf(arr[i]) != i) &#123; arr.splice(i, 1);//删除数组元素后数组长度减1后面的元素前移 i--;//数组下标回退 &#125; &#125; return arr; &#125;, /*数组相减*/ arrMinus: function (a, b) &#123; let lg=[],sm=[]; if(a.length&gt;=b.length)&#123; lg=a.concat(); sm=b.concat(); &#125;else&#123; lg=b.concat(); sm=a.concat(); &#125; // console.log(lg,sm) for (var i = lg.length - 1; i &gt;= 0; i--) &#123; a = lg[i]; for (var j = sm.length - 1; j &gt;= 0; j--) &#123; b = sm[j]; if (a == b) &#123; lg.splice(i, 1); sm.splice(j, 1); break; &#125; &#125; &#125; return lg; &#125;, /*添加图片*/ _addItimImg: function (&#123;elemId, hiddenId, list, picture, one = true&#125;) &#123; let that = this; // console.log(&apos;_addItimImg:&apos;,$(hiddenId).val()); let valArr = utils.strToArr($(hiddenId).val()); valArr[valArr.length] = picture; let valNew = utils.arrToStr(valArr); let $list = $(elemId).closest(&apos;.js-upload-group&apos;).find(list); let newId = &apos;id&apos; + (new Date().getTime()); let $item = `&lt;div class=&quot;layui-upload-item&quot;&gt; &lt;div class=&quot;layui-upload-item__child&quot; id=&quot;$&#123;newId&#125;&quot;&gt; &lt;img layer-src=&quot;$&#123;this.imgUrl(picture)&#125;&quot; src=&quot;$&#123;this.imgUrl(picture)&#125;&quot;&gt; &lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;layui-upload-img-del js-upload-img-del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt;`; if (one) &#123; $list.html($item); valNew = picture &#125; else &#123; $list.append($item); &#125; $(hiddenId).val(valNew); layer.msg(&apos;上传成功&apos;, &#123; icon: 1, time: 800 &#125;, function () &#123; that.photos(); &#125;); &#125;, /*删除图片列表中的图片*/ _delItemImg: function (&#123;$this, hiddenId, item&#125;) &#123; let that = this; // const itemId = $($this).closest(item).attr(&apos;id&apos;); layer.confirm(&apos;确定要删除该图片吗？&apos;, &#123; icon: 2 &#125;, function (index) &#123; layer.close(index); let thisFullSrc = $($this).closest(item).find(&apos;img&apos;).attr(&apos;src&apos;); console.log(thisFullSrc) let thisSrc = utils.strSubstr(thisFullSrc); let imgStr = $(hiddenId).val(); let imgArr = utils.strToArr(imgStr); let arrIndex = $.inArray(thisSrc, imgArr); imgArr.splice(arrIndex, 1); let newImgStr = utils.arrToStr(imgArr); $(hiddenId).val(newImgStr) $($this).closest(item).remove(); &#125;) &#125;, /*自定义input验证*/ verify: function () &#123; form.verify(&#123; nickname: function (value, item) &#123; //value：表单的值、item：表单的DOM对象 if (!new RegExp(&quot;^[a-zA-Z0-9_\u4e00-\u9fa5\\s·]+$&quot;).test(value)) &#123; return &apos;用户名不能有特殊字符&apos;; &#125; if (/(^\_)|(\__)|(\_+$)/.test(value)) &#123; return &apos;用户名首尾不能出现下划线\&apos;_\&apos;&apos;; &#125; if (/^\d+\d+\d$/.test(value)) &#123; return &apos;用户名不能全为数字&apos;; &#125; &#125; //我们既支持上述函数式的方式，也支持下述数组的形式 //数组的两个值分别代表：[正则匹配、匹配不符时的提示文字] , pass: [ /^[\S]&#123;6,12&#125;$/, &apos;密码必须6到12位，且不能出现空格&apos; ] //确认密码 , repass: function (value) &#123; if (value !== $(&apos;#newPassword&apos;).val()) &#123; return &apos;两次密码输入不一致&apos;; &#125; &#125;, positiveInteger: [ /^(0|[1-9]\d*)$/, &apos;请输入正整数&apos; ], money: [ /(^[1-9]([0-9]+)?(\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\.[0-9]([0-9])?$)/, &apos;金额只能保留小数点后两位&apos; ] &#125;); &#125;, /* 过滤掉formData的空值 */ formDataFilter: function (object) &#123; for (key in object) &#123; if (object[key] === &apos;&apos;) &#123; delete object[key] &#125; &#125; return object &#125;, /* 获取table数据,在回调函数callback里渲染table */ tableReq: function (options) &#123; let formData = options.formData, url = `$&#123;baseUrl&#125;$&#123;options.url&#125;`, type = options.type || &apos;GET&apos;, dataType = options.dataType || &apos;json&apos;, data = this.formDataFilter(options.data), callback = options.callback; admin.req(&#123; url: url, type: type, dataType: dataType, data: data, done: function (res) &#123; callback &amp;&amp; callback(res); &#125; &#125;) &#125;, /* 判断小屏，弹出层全屏 */ full: function (layerName) &#123; let screenNum = admin.screen(); if (screenNum === 0) &#123; layer.full(layerName); &#125; &#125; &#125;; /* 清空form数据 */ var $dateRest = $(&apos;.layui-form [type=&quot;reset&quot;]&apos;); $($dateRest).on(&apos;click&apos;, function () &#123; utils.reset($(this)); form.render(); return false; &#125;); // 输出test接口 exports(&apos;utils&apos;, utils);&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试七牛云图片]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87.html</url>
    <content type="text"><![CDATA[image.gooffwork.club image.xuziyu.cn]]></content>
  </entry>
  <entry>
    <title><![CDATA[把微信小程序异步API封装成为Promise，简化异步调用]]></title>
    <url>%2F%E6%8A%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%82%E6%AD%A5API%E5%B0%81%E8%A3%85%E6%88%90%E4%B8%BAPromise%EF%BC%8C%E7%AE%80%E5%8C%96%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.html</url>
    <content type="text"><![CDATA[把微信小程序异步API封装为Promise。用Promise处理异步操作会非常方便。 方法一 参考文章：把微信小程序异步api转化为Promise，方便异步编程 核心代码：12345678910111213141516// index.jsconst toPromise = (wx) =&gt; &#123; return (method) =&gt; &#123; return (option) =&gt; &#123; return new Promise ((resolve, reject) =&gt; &#123; wx[method](&#123; ...option, success: (res) =&gt; &#123; resolve(res) &#125;, fail: (err) =&gt; &#123; reject(err) &#125; &#125;) &#125;) &#125; &#125;&#125;export default toPromise 使用方法1.在需要用到的地方引入1import toPromise from &apos;/module/to-promise/src/index&apos; 2.绑定微信全局对象(wx)到函数，以便可以取到微信得API1const toPromiseWx = toPromise(wx) 3.开始转化你需要得异步API123//apiName为微信异步方法名，如对wx.request()进行转化const request = toPromiseWx(&apos;request&apos;)//直接使用request方法 举例12345678910111213141516171819import toPromise from &apos;/module/to-promise/src/index&apos;//转换wx.getStorage()const getStorage = toPromsie(wx)(&apos;getStorage&apos;) //使用getStorage(&#123; key: &apos;test&apos; &#125;) .then( (res) =&gt; &#123; //res的值与wx.getStorage(&#123; success: (res) =&gt; &#123;&#125; &#125;)中的res值一样 //res = &#123;data: &apos;keyValue&apos;&#125; console.log(res.data)//控制台打印storage中key对于的value return res.data//如果需要继续链式调用转化后的api，需要把值显示返回 &#125;, (err) =&gt; &#123; //err的值与wx.getStorage(&#123; success: (err) =&gt; &#123;&#125; &#125;)中的err值一样 throw err &#125; ) 方法二 参考文章：微信小程序：使用Promise简化回调因为微信小程序异步api都是success和fail的形式，所有有人封装了这样一个方法(核心方法):123456789//promisify.jsconst promisify = (api) =&gt; &#123; return (options, ...params) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; api(Object.assign(&#123;&#125;, options, &#123; success: resolve, fail: reject &#125;), ...params); &#125;); &#125;&#125;export default promisify 简单示例：12345678910// 获取系统信息wx.getSystemInfo(&#123; success: res =&gt; &#123; // success console.log(res) &#125;, fail: res =&gt; &#123; &#125;&#125;) 使用上面的promisify.js简化后:123456789import promisify from &apos;./promisify&apos;const getSystemInfo = promisify(wx.getSystemInfo)getSystemInfo().then(res=&gt;&#123; // success console.log(res)&#125;).catch(res=&gt;&#123;&#125;) 复杂的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344// 模拟获取code，然后将code传给后台，成功后获取userinfo，再将userinfo传给后台// 登录wx.login(&#123; success: res =&gt; &#123; let code = res.code // 请求 imitationPost(&#123; url: &apos;/test/loginWithCode&apos;, data: &#123; code &#125;, success: data =&gt; &#123; // 获取userInfo wx.getUserInfo(&#123; success: res =&gt; &#123; let userInfo = res.userInfo // 请求 imitationPost(&#123; url: &apos;/test/saveUserInfo&apos;, data: &#123; userInfo &#125;, success: data =&gt; &#123; console.log(data) &#125;, fail: res =&gt; &#123; console.log(res) &#125; &#125;) &#125;, fail: res =&gt; &#123; console.log(res) &#125; &#125;) &#125;, fail: res =&gt; &#123; console.log(res) &#125; &#125;) &#125;, fail: res =&gt; &#123; console.log(res) &#125;&#125;) 使用 promisify.js 简化后：12345678910111213141516171819202122232425262728293031323334353637import promisify from &apos;./promisify&apos;const login = promisify(wx.login)const getSystemInfo = promisify(wx.getSystemInfo)// 登录login().then(res =&gt; &#123; let code = res.code // 请求 pImitationPost(&#123; url: &apos;/test/loginWithCode&apos;, data: &#123; code &#125;, &#125;).then(data =&gt; &#123; // 获取userInfo getUserInfo().then(res =&gt; &#123; let userInfo = res.userInfo // 请求 pImitationPost(&#123; url: &apos;/test/saveUserInfo&apos;, data: &#123; userInfo &#125;, &#125;).then(data =&gt; &#123; console.log(data) &#125;).catch(res =&gt; &#123; console.log(res) &#125;) &#125;).catch(res =&gt; &#123; console.log(res) &#125;) &#125;).catch(res =&gt; &#123; console.log(res) &#125;)&#125;).catch(res =&gt; &#123; console.log(res)&#125;) 可以看到简化效果非常明显，赶紧把小程序的异步调用API统统封装一遍，就可以愉快的开发小程序了。]]></content>
      <categories>
        <category>前端</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端好用的框架及工具]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%A5%BD%E7%94%A8%E7%9A%84%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%B7%A5%E5%85%B7.html</url>
    <content type="text"><![CDATA[Taro UI 介绍Taro UI 是一款基于 Taro 框架开发的多端 UI 组件库。Taro 是由 京东·凹凸实验室 倾力打造的多端开发解决方案。现如今市面上端的形态多种多样，Web、ReactNative、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、RN 等）运行的代码。 特性 基于 Taro 开发 UI 组件 一套组件可以在 微信小程序，H5，ReactNative 等多端适配运行 提供友好的 API，可灵活的使用组件 开发者：京东 VUX 介绍VUX（读音 [v’ju:z]，同 views）是基于WeUI和Vue(2.x)开发的移动端 UI 组件库，主要服务于微信页面。基于webpack + vue-loader + vux可以快速开发移动端页面，配合vux-loader方便你在WeUI的基础上定制需要的样式。vux-loader保证了组件按需使用，因此不用担心最终打包了整个 vux 的组件库代码。VUX并不完全依赖于WeUI，VUX 在 WeUI 的基础上扩展了多个常用组件，但是尽量保持整体 UI 样式接近WeUI的设计规范。 个人开发者 Vant Weapp 介绍Vant Weapp 是有赞移动端组件库 Vant 的 小程序 版本，两者基于相同的视觉规范，提供一致的 API 接口，助力开发者快速搭建小程序应用。 开发者：有赞 Vant 介绍轻量、可靠的移动端 Vue 组件库 特性 50+ 个经过有赞线上业务检验的组件 单元测试覆盖率超过 90% 完善的文档和示例 支持 babel-plugin-import 支持 TypeScript 支持 SSR 开发者：有赞 Element 介绍网站快速成型工具Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 开发者：饿了没 D2 Admin 介绍优雅的管理系统前端集成方案 ElementUI组件库集成完善且强大的 ElementUI，随意搭配使用任何 ElementUI 组件。 模块化全局状态管理D2Admin 的系统管理为独立模块，在此模块内根据功能划分为十几个模块，每个模块都分工明确。 丰富集成已经为你准备好了很可能用到的插件和组件，专为 D2Admin 设计，或者来自第三方。 贴心小工具为您准备了实用的 JavaScript Util 以及 CSS 常用类。 开发者：FairyEver Mint UI 介绍基于 Vue.js 的移动端组件库 特性 Mint UI 包含丰富的 CSS 和 JS 组件，能够满足日常的移动端开发需要。通过它，可以快速构建出风格统一的页面，提升开发效率。 真正意义上的按需加载组件。可以只加载声明过的组件及其样式文件，无需再纠结文件体积过大。 考虑到移动端的性能门槛，Mint UI 采用 CSS3 处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。 依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。 开发者：饿了没 iView 介绍一套基于 Vue.js 的高质量 UI 组件库只能用于 pc 端 开发者：Aresn iView Weapp 一套高质量的 微信小程序 UI 组件库 开发者：Aresn Layui 经典模块化前端框架由职业前端倾情打造，面向所有层次的前后端开发者，零门槛开箱即用的前端 UI 解决方案 开发者：言心 jQuery WeUI 介绍jQuery WeUI 是专为微信公众账号开发而设计的一个简洁而强大的 UI 库，包含全部 WeUI 官方的 CSS 组件，并且额外提供了大量的拓展组件，丰富的组件库可以极大减少前端开发时间。 jQuery WeUI 的最大特点是它只提供 UI 组件，并不会对项目所使用的框架和其他库有任何的限制，几乎可以在任何环境下使用。无论你的项目是基于jQuery，还是 React, Angular, Vue， 你都会发现 jQuery WeUI 能非常方便的和他们结合使用。既是你的项目是一个有很悠久历史的老项目，也几乎可以做到拿来即用。 jQuery WeUI 提供了总共 30+ 个非常实用的组件：列表，表单，卡片，对话框，下拉刷新等。 开发者：言川 Ant Design 介绍服务于企业级产品的设计体系，基于确定和自然的设计价值观上的模块化解决方案，让设计者和开发者专注于更好的用户体验。基于 Ant Design 设计语言，我们提供了一套开箱即用的高质量 React 组件，用于开发和服务于企业级中后台产品，除官方的 React 实现，还有 Angular、Vue 的实现 开发者：蚂蚁金服 ANT DESIGN PRO 介绍开箱即用的中台前端/设计解决方案 开发者：蚂蚁金服 Ant Design Mobile 介绍一个基于 Preact / React / React Native 的 UI 组件库 开发者：蚂蚁金服 MinUI 介绍MinUI 是蘑菇街前端开发团队开发的基于微信小程序自定义组件特性开发而成的一套简洁、易用、高效的组件库，适用场景广，覆盖小程序原生框架，各种小程序组件主流框架等，并且提供了专门的命令行工具。 开发者：蘑菇街 Wux WeApp 介绍Wux WeApp也是一个非常不错的微信小程序自定义 UI 组件库，组件比较丰富，值得使用。 开发者：skyvow Touch UI 介绍WeTouch是 App 一站式快速开发平台，包含了 Touch UI 移动组件库、移动端常用 API、插件化机制、热更新、云端打包等内容。几乎囊括了开发移动应用的所有细节，真正实现拿来即用，像搭积木一样开发移动应用。使用它，你无需学习原生 native 开发，就可以一次拥有安卓 App、苹果 App 和 H5 等应用，极大地缩短项目周期。结合我们的Touch WX框架，还可以很方便的移植为微信小程序。WeTouch与Touch UI二者具有相同的开发方式，区别在于：Touch UI属于WeTouch的组件库部分，只能开发 H5 应用，而WeTouch包含了Touch UI，既能做 App 又能做 H5 应用。 Touch WX 介绍Touch WX是一套完全免费的微信小程序开发框架，包含丰富的 UI 控件用于官方组件的补充。与WeTouch开发方式很相似，也是通过 VSCode 编辑器+插件的方式开发，经过编译后输出小程序代码。当你用WeTouch开发了应用，可以直接导入到 Touch WX 进行转换，稍作调整就能生成小程序。反之也同样，当你TouchUI WX开发了微信小程序，可以导出为Touch UI工程来生成 H5 应用或 App。 工具推妹子 介绍最养眼的前端占位图]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nvm-windows控制nodeJs版本]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8nvm-windows%E6%8E%A7%E5%88%B6nodeJs%E7%89%88%E6%9C%AC.html</url>
    <content type="text"><![CDATA[为了在windows系统中切换不同开发环境的nodeJs版本依赖。决定使用nvm-windows来管理nodeJs版本。 安装步骤 下载首先从nvm官网下载安装包 ，选择setup版本的，解压后里面是一个exe，安装方式就如同一个常见的exe安装包，双击运行即可 配置nvm的安装位置，任意一个你喜欢的位置都可以（这个文件夹的名字一定不能含有中文或空格！）。 设置node的symlink文件夹位置。（这个文件夹的名字一定不能含有中文或空格！） 上面两个步骤目录出现空格，在使用nvm use的时候会报错exit status 1 如果在安装nvm之前，电脑上就已经安装有node的，会看到如下图，询问你是否用nvm管理已经存在的node版本。一定要选是，这个弹窗可能会出现好几次，都点是。 安装完成 配置步骤 检查nvm是否安装成功使用管理员权限打开一个命令行。输入nvm v，会显示nvm的版本号，有则表示安装成功。 使用淘宝node镜像，使用淘宝npm镜像nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 安装指定版本的node： nvm install 版本号比如安装8.11.3：nvm install 8.11.3 查看当前电脑上已经安装的全部node版本,正在使用中的版本号前有个星号*nvm ls 切换nodeJs版本比如使用8.11.3：nvm use 8.11.3 常用命令 安装指定版本的node： nvm install 版本号nvm install 8.9.3 使用指定版本的node： nvm use 版本号nvm use 8.9.3 使用淘宝node镜像：nvm node_mirrornvm node_mirror https://npm.taobao.org/mirrors/node/ 使用淘宝npm镜像：nvm npm_mirrornvm npm_mirror https://npm.taobao.org/mirrors/npm/ 查看当前电脑上已经安装的全部node版本,正在使用中的版本号前有个星号*：nvm ls 查看可用的（可下载的）全部node版本：nvm ls available]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>nvm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layui&layuiAdmin 爬坑文档]]></title>
    <url>%2Flayui-layuiAdmin%E7%88%AC%E5%9D%91%E6%96%87%E6%A1%A3.html</url>
    <content type="text"><![CDATA[table 数据更新，工具栏无法联动变化 原因：table 对非对应 field 更新数据是无法响应的。没有 templet 字段就没法让 update()识别。 将工具栏和变动状态栏合并。缺点是table 结构限制，优点是代码简单。 方案一 把工具栏和相关联的 field 的合并，工具栏需要添加 templet:#tool_ID 用来让 update()识别，从而更新完成,必须是 withdraw_state 这一列没有，可以有更好的展示效果 123456789101112&lt;table id="tableAccount" lay-filter="tableAccount"&gt;&lt;/table&gt;&lt;!-- 将提现状态和操作合并到一栏 --&gt;&lt;script type="text/html" id="tableToolBar"&gt; &#123;&#123;# if(d.withdraw_state == 'default')&#123; &#125;&#125; &lt;a class="layui-btn layui-btn-xs" lay-event="success"&gt;通过&lt;/a&gt; &lt;a class="layui-btn layui-btn-xs layui-btn-danger" lay-event="fail"&gt;驳回&lt;/a&gt; &#123;&#123;# &#125; else if(d.withdraw_state == 'success')&#123; &#125;&#125; &lt;span class="layui-badge layui-bg-gray"&gt;已成功&lt;/span&gt; &#123;&#123;# &#125; else if(d.withdraw_state == 'fail')&#123; &#125;&#125; &lt;span class="layui-badge layui-bg-gray"&gt;已失败&lt;/span&gt; &#123;&#123;# &#125; &#125;&#125;&lt;/script&gt; 123456789&#123; field: 'withdraw_state', title: '操作', fixed: 'right', width: 180, align: 'center', templet: '#tableToolBar', toolbar: '#tableToolBar'&#125; 使用.update()更新 table 数据，然后工具栏会变化 1234obj.update(&#123; withdraw_state: 'success', withdraw_time: time,&#125;); 使用 layui 的 laytpl 来对工具栏进行更新。缺点是代码量大，逻辑复杂，优点是适用性强。 方案二 使用 updata 更新 table,原因：因为不是对应 field 的数据，所以[data-field=”toolStatus”]所在的工具条不支持更新， 1.只能通过使用 laytpl 获取到更新后的代码模板， 2.操纵 tr = obj.tr 找到 tool 对应的 field(‘td[data-field=”toolStatus”]’),找到对饮 field 下面的的 div 用 html()更新 tool 内容 。 状态和操作是分开两列的。 1234567891011121314&#123; field: 'withdraw_state', title: '提现状态', templet: '#withdraw_state'&#125;,&#123; field: 'toolStatus', title: '操作', fixed: 'right', width: 180, align: 'center', templet: '#tableToolBar', toolbar: '#tableToolBar'&#125; 1234567891011121314var timestamp = new Date(1527837613 * 1000);var time = utils.formatTime(timestamp);obj.update(&#123; withdraw_state: 'success', withdraw_time: time,&#125;);data.withdraw_state = 'success';laytpl(tableToolBar.innerHTML).render(obj.data, function(html) &#123; //tableToolBar为toolbar的script模板id toolhtml = html;&#125;);tr.children('td[data-field="toolStatus"]') .children('div') .html(toolhtml); //toolStatus为当前表格工具列是表格的第几列 重载 table 的当前页，缺陷是可能 table 的数据量变化，导致当前行不在当前页了，优点是代码量少。 方案三 使用.layui-laypage-btn(表格分页中的确定按钮)，重载当前页面 1$('.layui-laypage-btn').trigger('click');]]></content>
  </entry>
  <entry>
    <title><![CDATA[创建py文件时自定义头部模板]]></title>
    <url>%2F%E5%88%9B%E5%BB%BApy%E6%96%87%E4%BB%B6%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E9%83%A8%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[Pycharm: 打开软件进行设置，默认使用utf-8格式File-&gt;settings-&gt;Editor-&gt;File and Code Templates-&gt;Python Script1234567#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : $&#123;DATE&#125; $&#123;TIME&#125;# @Author : Aries# @Site : $&#123;SITE&#125;# @File : $&#123;NAME&#125;.py# @Software: $&#123;PRODUCT_NAME&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue3.0快速创建项目&配置]]></title>
    <url>%2Fvue3-0%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE-%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[本地安装vue-cli 前置条件 更新npm到最新版本 命令行运行:npm install -g npmnpm就自动为我们更新到最新版本 淘宝npm镜像使用方法 npm config set registry https://registry.npm.taobao.orgcnpm config set registry https://registry.npm.taobao.orgyarn config set registry https://registry.npm.taobao.org配置后可通过下面方式来验证是否成功 ： npm config get registry 使用 npm 全局安装 vue-cli ：npm i -g @vue/cli@3.0.0-beta.6 创建项目 执行：vue create my-project 此处有两个选择： default (babel, eslint)默认套餐，提供babel和eslint支持 Manually select features自己去选择需要的功能，提供更多的特性选择。比如如果想要支持 TypeScript ，就应该选择这一项。 可以使用上下方向键来切换选项。如果只需要 babel 和 eslint 支持，那么选择第一项，就完事了，静静等待 vue 初始化项目。 vue-cli 内置支持了8个功能特性，可以多选：使用方向键在特性选项之间切换，使用空格键选中当前特性，使用 a 键切换选择所有，使用 i 键翻转选项。 对于每一项的功能，此处做个简单描述： TypeScript 支持使用 TypeScript 书写源码 Progressive Web App (PWA) Support PWA 支持。 Router 支持 vue-router 。 Vuex 支持 vuex 。 CSS Pre-processors 支持 CSS 预处理器。 Linter / Formatter 支持代码风格检查和格式化。 Unit Testing 支持单元测试。 E2E Testing 支持 E2E 测试。 我选择了 Router，Vuex，CSS Pre-processors，Linter / Formatter 按住enter进入下一步，接下来都是对之前每项选项的更详细的选择。 css选择SCSS/SASS Linter / Formatter选择prettier 这一步就是要选择配置文件的位置了。对于 Babel 、 PostCSS 等，都可以有自己的配置文件： .babelrc 、 .postcssrc 等等，同时也可以把配置信息放在 package.json 里面。此处出于对编辑器（ Visual Studio Code ）的友好支持（编辑器一般默认会在项目根目录下寻找配置文件），选择把配置文件放在外面，选择 In dedicated config files 待补充 Save this as a preset for future projects?这个就是问要不要把当前的这一系列选项配置保存起来，方便下一次创建项目时复用。选择y。 选完之后， vue-cli 就根据前面选择的内容，开始初始化项目了。 启动项目 初始完之后，进入到项目根目录：cd my-project启动项目：npm run serve稍等一会儿，可以看到自动在浏览器中打开了 安装PostCSS插件 通过Vue-cli构建的项目，在项目的根目录下有一个.postcssrc.js，默认情况下已经有了：1234567module.exports = &#123; plugins: &#123; autoprefixer: &#123;&#125; &#125;&#125;``` 配置成 module.exports = { plugins: { “postcss-import”:{}, “postcss-url”:{}, “autoprefixer”: {} }}123456789101112131415161718 - 安装`postcss-import`和`postcss-url`插件 * `$ npm install postcss-import`和`$ npm install postcss-url` * `postcss-import`相关配置[*点击这里*](http://github.com/postcss/postcss-import &quot;postcss-import的github仓库&quot;)。主要功有是解决`@import`引入路径问题。使用这个插件，可以让你很轻易的使用本地文件、`node_modules`或者`web_modules`的文件。这个插件配合`postcss-url`让你引入文件变得更轻松。 * `postcss-url`相关配置可以[*点击这里*](https://github.com/postcss/postcss-url &quot;postcss-url的github仓库&quot;)。该插件主要用来处理文件，比如图片文件、字体文件等引用路径的处理。在Vue项目中，`vue-loader`已具有类似的功能，只需要配置中将`vue-loader`配置进去。 * `autoprefixer`插件是用来自动处理浏览器前缀的一个插件。如果你配置了`postcss-cssnext`，其中就已具备了`autoprefixer`的功能。在配置的时候，未显示的配置相关参数的话，表示使用的是[`Browserslist`](https://github.com/ai/browserslist &quot;Browserslist的github仓库地址&quot;)指定的列表参数，你也可以像这样来指定`last 2 versions` 或者 `&gt; 5%`。如此一来，你在编码时不再需要考虑任何浏览器前缀的问题，可以专心撸码。这也是PostCSS最常用的一个插件之一。 ### 其他插件 我们要完成vw的布局兼容方案，或者说让我们能更专心的撸码，还需要配置下面的几个PostCSS插件：* [postcss-aspect-ratio-mini](http://github.com/yisibl/postcss-aspect-ratio-mini)* [postcss-px-to-viewport](http://github.com/evrone/postcss-px-to-viewport)* [postcss-write-svg](http://github.com/jonathantneal/postcss-write-svg)* [postcss-cssnext](http://github.com/MoOx/postcss-cssnext)* [cssnano](http://github.com/ben-eb/cssnano)* [postcss-viewport-units](http://github.com/springuper/postcss-viewport-units) 要使用 安装成功后，在项目根目录下的`package.json`文件中，可以看到新安装的依赖包： “dependencies”: { “cssnano”: “^3.10.0”, “postcss-aspect-ratio-mini”: “^0.0.2”, “postcss-cssnext”: “^3.1.0”, “postcss-import”: “^11.1.0”, “postcss-px-to-viewport”: “^0.0.3”, “postcss-url”: “^7.3.2”, “postcss-viewport-units”: “^0.1.4”, “postcss-write-svg”: “^3.0.1”, “vue”: “^2.5.16”, “vue-router”: “^3.0.1”, “vuex”: “^3.0.1” },1接下来在`.postcssrc.js`文件对新安装的`PostCSS`插件进行配置： module.exports = { plugins: { “postcss-import”: {}, “postcss-url”: {}, //“autoprefixer”: {}, “postcss-aspect-ratio-mini”: {}, “postcss-write-svg”: { utf8: false }, “postcss-cssnext”: {}, “postcss-px-to-viewport”: { viewportWidth: 750, //视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, //视窗的高度，根据750设备的宽度来置顶，一般指定1334，也可以不配置 unitPrecision: 3, //指定’px’转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: ‘vw’, //指定需要转换成的视窗单位，建议使用vw selectorBlackList: [‘.ignore’, ‘.hairlines’, ‘.g-vw-no’], //指定不转行为视窗单位的类，可以自定义，可以无限添加，建议定义一至两个通用的类名 minPixeValue: 1, //小于或等于’1px’不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false //允许在媒体查询中转换’px’ }, “postcss-viewport-units”: {}, “cssnano”: { preset: “advanced”, autoprefixer: false, “postcss-zindex”: false } }}12345678910111213&gt; 特别声明：由于`cssnext`和`cssnano`都具有`autoprefixer`,事实上只需要一个，所以把默认的`autoprefixer`删除掉，然后把`cssnano`中的`autoprefixer`设置为`false`。对于其他的插件使用，稍后会简单的介绍。由于配置文件修改了，所以重新跑一下`npm run dev`。项目就可以正常看到了。接下来简单的介绍一下后面安装的几个插件的作用。##### postcss-cssnext`postcss-cssnext`其实就是`cssnext`。该插件可以让我们使用CSS未来的特性，其会对这些特性做相关的兼容性处理。其包含的特性主要有： 有关于cssnext的每个特性的操作文档，可以[点击这里](http://cssnano.co/guides/getting-started/)浏览。##### cssnano`cssnano`主要用来压缩和清理`CSS`代码。在`Webpack`中，`cssnano`和`css-loader`捆绑在一起，所以不需要自己加载它。不过你也可以使用`postcss-loader`显式的使用`cssnano`。有关于`cssnano`的详细文档，可以点击这里获取。在`cssnano`的配置中，使用了`preset: &quot;advanced&quot;`，所以我们需要另外安装： npm i cssnano-preset-advanced –save-dev1`cssnano`集成了一些其他的`PostCSS`插件，如果你想禁用`cssnano`中的某个插件的时候，可以像下面这样操作： “cssnano”: { autoprefixer: false, “postcss-zindex”: false}123456上面的代码把`autoprefixer`和`postcss-zindex`禁掉了。前者是有重复调用，后者是一个讨厌的东东。只要启用了这个插件，`z-index`的值就会重置为1。这是一个天坑，***千万记得将`postcss-zindex`设置为`false`***。postcss-px-to-viewportpostcss-px-to-viewport插件主要用来把px单位转换为vw、vh、vmin或者vmax这样的视窗单位，也是vw适配方案的核心插件之一。在配置中需要配置相关的几个关键参数： “postcss-px-to-viewport”: { viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定px转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: ‘vw’, // 指定需要转换成的视窗单位，建议使用vw selectorBlackList: [‘.ignore’, ‘.hairlines’], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于1px不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换px}1目前出视觉设计稿，我们都是使用750px宽度的，那么100vw = 750px，即1vw = 7.5px。那么我们可以根据设计图上的px值直接转换成对应的vw值。在实际撸码过程，不需要进行任何的计算，直接在代码中写px，比如： .test { border: .5px solid black; border-bottom-width: 4px; font-size: 14px; line-height: 20px; position: relative;}[w-188-246] { width: 188px;} 编译出来的CSS： .test { border: .5px solid #000; border-bottom-width: .533vw; font-size: 1.867vw; line-height: 2.667vw; position: relative;}[w-188-246] { width: 25.067vw;}1在不想要把`px`转换为`vw`的时候，首先在对应的元素（`html`）中添加配置中指定的类名`.ignore`或`.hairlines`(`.hairlines`一般用于设置`border-width:0.5px`的元素中)： 1写CSS的时候： .ignore { margin: 10px; background-color: red;}.box { width: 180px; height: 300px;}.hairlines { border-bottom: 0.5px solid red;}1编译出来的CSS: .box { width: 24vw; height: 40vw;}.ignore { margin: 10px; /.box元素中带有.ignore类名，在这个类名写的px不会被转换/ background-color: red;}.hairlines { border-bottom: 0.5px solid red;}12345678910上面解决了`px`到`vw`的转换计算。那么在哪些地方可以使用`vw`来适配我们的页面。根据相关的测试：* 容器适配，可以使用vw* 文本的适配，可以使用vw* 大于1px的边框、圆角、阴影都可以使用vw* 内距和外距，可以使用vw##### postcss-aspect-ratio-mini[`postcss-aspect-ratio-mini`](http://github.com/yisibl/postcss-aspect-ratio-mini)主要用来处理元素容器宽高比。在实际使用的时候，具有一个默认的结构 1在实际使用的时候，你可以把自定义属性`aspectratio`和`aspectratio-content`换成相应的类名，比如： 1我个人比较喜欢用__自定义属性__，它和类名所起的作用是同等的。结构定义之后，需要在你的样式文件中添加一个**统一的宽度比默认属性**： [aspectratio] { position: relative;}[aspectratio]::before { content: ‘’; display: block; width: 1px; margin-left: -1px; height: 0;}/aspectratio-content存放内容，自由填满，利用伪元素::before和::after来撑开容器/[aspectratio-content] { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%;}1如果我们想要做一个`188:246`（`188`是容器宽度，`246`是容器高度）这样的比例容器，只需要这样使用： [w-188-246] { aspect-ratio: ‘188:246’;}1有一点需要特别注意：`aspect-ratio`属性不能和其他属性写在一起，否则编译出来的属性只会留下`aspect-ratio`的值，比如： 1编译前的CSS如下： [w-188-246] { width: 188px; background-color: red; aspect-ratio: ‘188:246’;}1编译之后： [w-188-246]:before { padding-top: 130.85106382978725%;}1主要是因为在插件中做了相应的处理，不在每次调用`aspect-ratio`时，生成前面指定的默认样式代码，这样代码没那么冗余。所以在使用的时候，需要把`width`和`background-color`分开来写： [w-188-246] { width: 188px; background-color: red;}[w-188-246] { aspect-ratio: ‘188:246’;}1这个时候，编译出来的CSS就正常了： [w-188-246] { width: 25.067vw;/撑开宽度/ background-color: red;}[w-188-246]:before { padding-top: 130.85106382978725%;/撑开高度/}1234567891011有关于宽高比相关的详细介绍，如果大家感兴趣的话，可以阅读下面相关的文章：* [CSS实现长宽比的几种方案](http://www.w3cplus.com/css/aspect-ratio.html)* [容器长宽比](http://www.w3cplus.com/css/aspect-ratio-boxes.html)* [Web中如何实现纵横比](http://www.w3cplus.com/css/experiments-in-fixed-aspect-ratios.html)* [实现精准的流体排版原理](http://www.w3cplus.com/css/css-polyfluidsizing-using-calc-vw-breakpoints-and-linear-equations.html)&gt; 目前采用`PostCSS`插件只是一个过渡阶段，在将来我们可以直接在CSS中使用`aspect-ratio`属性来实现长宽比。##### postcss-write-svg[`postcss-write-svg`](http://github.com/jonathantneal/postcss-write-svg)插件主要用来处理移动端`1px`的解决方案。该插件主要使用的是`border-image`和`background`来做`1px`的相关处理。比如： @svg 1px-border { height: 2px; @rect { fill: var(–color, black); width: 100%; height: 50%; }}.example { border: 1px solid transparent; border-image: svg(1px-border param(–color #00b1ff)) 2 2 stretch;}1编译出来的CSS: .example { border: 1px solid transparent; border-image: url(“data:image/svg+xml;charset=utf-8,%3Csvg xmlns=’http://www.w3.org/2000/svg&#39; height=’2px’%3E%3Crect fill=’%2300b1ff’ width=’100%25’ height=’50%25’/%3E%3C/svg%3E”) 2 2 stretch;}1上面演示的是使用`border-image`方式，除此之外还可以使用`background-image`来实现。比如： @svg square { @rect { fill: var(–color, black); width: 100%; height: 100%; }} #example { background: white svg(square param(–color #00b1ff));}1编译出来就是： #example { background: white url(“data:image/svg+xml;charset=utf-8,%3Csvg xmlns=’http://www.w3.org/2000/svg&#39;%3E%3Crect fill=’%2300b1ff’ width=’100%25’ height=’100%25’/%3E%3C/svg%3E”);}123456789101112131415161718解决`1px`的方案除了这个插件之外，还有其他的方法。可以阅读前期整理的《[再谈Retina下`1px`的解决方案](http://www.w3cplus.com/css/fix-1px-for-retina.html)》一文。&gt; **特别声明**：由于有一些低端机对`border-image`支持度不够友好，个人建议你使用`background-image`的这个方案。##### CSS ModulesVue中的`vue-loader`已经集成了[CSS Modules](http://github.com/css-modules/css-modules)的功能，个人建议在项目中开始使用CSS Modules。特别是在Vue和React的项目中，CSS Modules具有很强的优势和灵活性。建议看看CSS In JS相关的资料。在Vue中，使用CSS Modules的相关文档可以阅读Vue官方提供的文档[《CSS Modules》](http://vue-loader.vuejs.org/en/features/css-modules.html)。##### postcss-viewport-units[`postcss-viewport-units`](http://github.com/springuper/postcss-viewport-units)插件主要是给CSS的属性添加`content`的属性，配合[`viewport-units-buggyfill`](http://github.com/rodneyrehm/viewport-units-buggyfill)库给`vw`、`vh`、`vmin`和`vmax`做适配的操作。这是实现`vw`布局必不可少的一个插件，因为少了这个插件，这将是一件痛苦的事情。后面你就清楚。到此为止，有关于所需要的PostCSS已配置完。并且简单的介绍了各个插件的作用，至于详细的文档和使用，可以参阅对应插件的官方文档。### vw兼容方案使用`viewport`的`polyfill`：`Viewport Units Buggyfill`。使用`viewport-units-buggyfill`主要分以下几步走：##### 引入JavaScript文件`viewport-units-buggyfill`主要有两个JavaScript文件：`viewport-units-buggyfill.js`和`viewport-units-buggyfill.hacks.js`。你只需要在你的HTML文件中引入这两个文件。比如在Vue项目中的`index.html`引入它们： 123你也可以使用其他的在线CDN地址，也可将这两个文件合并压缩成一个`.js`文件。这主要看你自己的兴趣了。第二步，在HTML文件中调用`viewport-units-buggyfill`，比如： window.onload = function () { window.viewportUnitsBuggyfill.init({ hacks: window.viewportUnitsBuggyfillHacks }); }12345678910111213141516171819202122232425为了你Demo的时候能获取对应机型相关的参数，我在示例中添加了一段额外的代码，估计会让你有点烦：```javascript&lt;script&gt;window.onload = function () &#123; window.viewportUnitsBuggyfill.init(&#123; hacks: window.viewportUnitsBuggyfillHacks &#125;); var winDPI = window.devicePixelRatio; var uAgent = window.navigator.userAgent; var screenHeight = window.screen.height; var screenWidth = window.screen.width; var winWidth = window.innerWidth; var winHeight = window.innerHeight; alert( &quot;Windows DPI:&quot; + winDPI + &quot;;\ruAgent:&quot; + uAgent + &quot;;\rScreen Width:&quot; + screenWidth + &quot;;\rScreen Height:&quot; + screenHeight + &quot;;\rWindow Width:&quot; + winWidth + &quot;;\rWindow Height:&quot; + winHeight ) &#125;&lt;/script&gt; 具体的使用。在你的CSS中，只要使用到了viewport的单位（vw、vh、vmin或vmax ）地方，需要在样式中添加content：123456789.my-viewport-units-using-thingie &#123; width: 50vmin; height: 50vmax; top: calc(50vh - 100px); left: calc(50vw - 100px); /* hack to engage viewport-units-buggyfill */ content: &apos;viewport-units-buggyfill; width: 50vmin; height: 50vmax; top: calc(50vh - 100px); left: calc(50vw - 100px);&apos;;&#125; 这可能会令你感到恶心，而且我们不可能每次写vw都去人肉的计算。特别是在我们的这个场景中，咱们使用了postcss-px-to-viewport这个插件来转换vw，更无法让我们人肉的去添加content内容。 这个时候就需要前面提到的postcss-viewport-units插件。这个插件将让你无需关注content的内容，插件会自动帮你处理。 Viewport Units Buggyfill还提供了其他的功能。详细的这里不阐述了。但是content也会引起一定的副作用。比如img和伪元素::before(:before)或::after（:after）。在img中content会引起部分浏览器下，图片不会显示。这个时候需要全局添加：123img &#123; content: normal !important;&#125; 而对于::after之类的，就算是里面使用了vw单位，Viewport Units Buggyfill对其并不会起作用。比如：1234567891011121314151617// 编译前.after &#123; content: &apos;after content&apos;; display: block; width: 100px; height: 20px; background: green;&#125;// 编译后.after[data-v-469af010] &#123; content: &quot;after content&quot;; display: block; width: 13.333vw; height: 2.667vw; background: green;&#125; 这个时候我们需要通过添加额外的标签来替代伪元素（这个情景我没有测试到，后面自己亲测一下）。 到了这个时候，你就不需要再担心兼容问题了。整个示例的源码，可以点击这里下载。 如果你下载了示例源码，先要确认你的系统环境能跑Vue的项目，然后下载下来之后，解压缩，接着运行npm i，再运行npm run dev，你就可以看到效果了。 打包上线 在开发完项目之后，就应该打包上线了。 vue-cli 也提供了打包的命令，在项目根目录下执行：npm run build执行完之后，可以看到在项目根目录下多出了一个 dist 目录，该目录下就是打包好的所有静态资源，直接部署到静态资源服务器就好了。实际上，在部署的时候要注意，假设静态服务器的域名是 http://static.baidu.com ，那么对应到访问 &lt;项目根目录&gt;/dist/index.html 的 URL 一定要是 http://static.baidu.com/index.html ，其他的静态资源以此类推。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue解决跨域问题]]></title>
    <url>%2Fvue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[如果把所有的接口，统一规范为一个入口，在一定程度上会解决冲突 proxyTable: { &apos;/api/**&apos;: { //使用&quot;/api&quot;来代替&quot;源地址&quot; target: &apos;http://www.qiangchebao.cn/ver100&apos;, //源地址 changeOrigin: true, //改变源 pathRewrite: { &apos;^/api&apos;: &apos;/&apos; //路径重写 } } }, 上面这个代码，就是把咱们虚拟的这个api接口，去掉，此时真正去后端请求的时候，不会加上api这个前缀了，那么这样我们前台http请求的时候，还必须加上api前缀才能匹配到这个代理,代码如下： logout(){ axios.post(&apos;/api/users/logout&apos;).then(result=&gt; { let res = result.data; this.nickName = &apos;&apos;; console.log(res); }) }, 我们可以利用axios的baseUrl直接默认值是 api，这样我们每次访问的时候，自动补上这个api前缀，就不需要我们自己手工在每个接口上面写这个前缀了在入口文件里面配置如下： import Axios from &apos;axios&apos; import VueAxios from &apos;vue-axios&apos; Vue.use(VueAxios, Axios) Axios.defaults.baseURL = &apos;api&apos; //如果这配置 &apos;api/&apos; 会默认读取本地的域 vue-axios的用法 Vue.axios.get(api).then((response) =&gt; { console.log(response.data) }) this.axios.get(api).then((response) =&gt; { console.log(response.data) }) this.$http.post(api,{params}).then((response) =&gt; { console.log(response.data) }) 在使用post方式的时候传递参数有两种方式，一种是普通的formed方式，一种是json方式，如果后台接受的是普通方式，那么使用上述方式即可。 普通的formed方式 默认情况下，axios串联js对象为 JSON 格式。使用 application/x-www-form-urlencoded 格式化浏览器 Browser在浏览器中你可以如下使用 URLSearchParams API:1234var params = new URLSearchParams();params.append(&apos;param1&apos;,&apos;value1&apos;);params.append(&apos;param2&apos;,&apos;value2&apos;);axios.post(&apos;/foo&apos;,params); 注意： URLSearchParams 不支持所有的浏览器 其他方法：你可以使用 qs 库来格式化数据。 var qs = require(&apos;qs&apos;); axios.post(&apos;/foo&apos;, qs.stringify({&apos;bar&apos;:123})); json方式 data: {&apos;bar&apos;:123} 上面这样配置的话，不会区分生产和开发环境，在config 文件夹里面新建一个 api.config.js 配置文件，用来分别设置不同环境。 const isPro = Object.is(process.env.NODE_ENV, &apos;production&apos;) module.exports = { baseUrl: isPro ? &apos;http://www.qiangchebao.cn/ver100&apos; : &apos;api/&apos; } 然后在 main.js 里面引入,这样可以保证动态的匹配生产和开发的定义前缀 //引入api.config.js import apiConfig from &apos;../config/api.config&apos; import Axios from &apos;axios&apos; import VueAxios from &apos;vue-axios&apos; Vue.use(VueAxios, Axios) //根据环境设置axios的baseurl Axios.defaults.baseURL = apiConfig.baseUrl 经过上面配置后，在dom里面可以这样轻松的访问,也不需要在任何组件里面引入axios模块了。 在dom里面请求api的姿势 this.$http .post( &quot;/car/getCarDetail&quot;, qs.stringify({ car_id: carId }) ) .then(res =&gt; { console.log(res); });]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue,环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript工具函数]]></title>
    <url>%2Fjavascript%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[前端获取url参数123456789function getQueryString(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &apos;i&apos;); // 匹配目标参数 var result = window.location.search.substr(1).match(reg); // 对querystring匹配目标参数 if (result != null) &#123; return decodeURIComponent(result[2]);//对 encodeURIComponent() 函数编码的 URI 进行解码。 &#125; else &#123; return null; &#125; &#125; 调用函数获取url参数 var user = parseInt(getQueryString(&apos;user&apos;),10)||null;//获取user的参数并转换成10进制数字 jquery的$.ajax()设置$.ajaxSetup({ beforeSend:function(){ //loading带文字 $.showLoading(); }, error: function (err) { console.log(&quot;发生错误：&quot;, err) $.hideLoading(); }, dataFilter:function (data,type) { $.hideLoading(); return data; } });]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极验证-geetest-前端配置]]></title>
    <url>%2F%E6%9E%81%E9%AA%8C%E8%AF%81-geetest-%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[在公司项目《玩客小兵》中，登陆或者注册的场景中需要进行人机验证，使用了第三方插件极验证-geetest。 插件效果 安装 引入初始化函数 1&lt;script src=&quot;gt.js&quot;&gt;&lt;/script&gt; 调用初始化函数进行初始化 $.ajax({ // 获取id，challenge，success（是否启用failback） url: &quot;/user/startCaptchaServlet?t=&quot; + (new Date()).getTime(), // 后台接口，加随机数防止缓存 type: &quot;get&quot;, dataType: &quot;json&quot;, success: function (data) { console.log(data); // 使用initGeetest接口 // 参数1：配置参数 initGeetest({ gt: data.gt, challenge: data.challenge, new_captcha: data.new_captcha, product: &quot;embed&quot;, // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效 offline: !data.success // 表示用户后台检测极验服务器是否宕机，一般不需要关注 }, // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件 handlerEmbed); } }); 初始化成功后，使用回调函数 var handlerEmbed = function (captchaObj) { var this_data = { mobile: null, type: &apos;signup&apos; }; //点击下一步 $(&quot;.js-next-login&quot;).click(function (e) { $(&apos;.geetest_btn&apos;).trigger(&apos;click&apos;); }); // 监听验证成功事件 captchaObj.onSuccess(function () { //如果验证成功，就执行相关代码 }); // 将验证码加到id为captcha的元素里，同时会有三个input的值：geetest_challenge, geetest_validate, geetest_seccode captchaObj.appendTo(&quot;#embed-captcha&quot;); captchaObj.onReady(function () { }); };]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax原理]]></title>
    <url>%2FAjax%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[Ajax前端相关的技术点 html 主要用来实现页面的排版布局 css 主要用来实现页面的样式美化 javaScript 主要用来实现前端功能特效 采用上面的这些技术开发的页面和前端特效脚本需要放到服务器才能够对外提供服务，才能够让互联网上的网友看到。 客户端与服务器 本质上都是计算机，只不过样子不同，配置不同，应用场景不同（安装的应用软件不同） 客户端主要用于普通上网用户 服务器主要给上网用户提供后台服务 网络相关概念 IP地址（唯一的确定互联网上的一台计算机） 域名 IP地址的别名，方便记忆 DNS 用于维护IP地址与域名的关系 端口 用来确定计算机上的网络应用程序 通信协议理解 通信双方约定的规则 http/https 超为本传输协议 ftp 文件传输协议 smpt/pop3 邮件收发协议 …… 网站 网站由一系列页面组成（页面由js、css、图片、html标签。。。所有的这些文件都被称为资源） 静态网站 就是提前写好的html页面（包括图片、媒体文件。。。静态资源文件），并且部署到服务器上 静态网站主要存在的问题： 随着网站规模的增大可维护性逐渐降低 没有交互性 动态网站 动态指的是html页面是动态生成的，这里动态生成的不一定是一个完整的页面，有可能仅仅是页面的一部分，或者仅仅是数据(普通字符串、json、xml) 实现动态网站的技术： php java（jsp） .net Node.js python …… http 协议get | 用来获取数据post | 用来添加数据put | 用来修改数据delete | 用来删除数据 http 协议的常用请求方式: 增删改查 PHP基础语法&lt;?php PHP的所有语法都写在这个地方 ?&gt; PHP文件文件格式是 xxx.php; 变量 变量以$开头 字母/数字/下划线 不能以数字开头，大小写敏感。 字符串拼接 PHP中字符串拼接用” . “; 单引号 PHP中的单引号把包含在其中的变量当作为普通的字符串来处理; 双引号 PHP中的双引号把包含在其中的变量当作变量解析成变量值; 运算符 与javaScript基本类似; 数据类型 字符串 整型 浮点型 布尔型 数组 对象 NULL gettype: 是内置数据类型的判断 输出内容 echo: 输出简单数据类型, 如字符串, 数值; print_r(): 输出复杂数据类型, 如数组; var_dump 输出详细信息, 如对象, 数组; 分之循环 if/switch while for count()内置函数, 计算数组的长度; foreach foreach($arr as $key =&gt; $value){ }; 函数 自定义函数 语法类似与JavaScript的自定义函数; 系统函数 直接调用, 不需要声明; json_encode(); 将数组和对象转换为字符串的方法;预定义变量 $_GET $_GET请求参数获取 $_GET是专门用来接数据用的一个全局数组; form 默认请求方式就是get请求, get请求会把表单数据作为url的参数进行提交; $_POST $_POST请求参数获取 设置服务响应的文件类型: header(“Content-Type: text/plain; charset=utf-8”); header(“Content-Type: text/html; charset=utf-8”); $_POST也是PHP内置好的专门用来接数据用的一个全局数组; GET与POST请求方式的差异 GET没有请求主体, 使用xhr.send(null); GET可以通过在请求URL上添加请求参数; POST有请求主体, 可以通过;xhr.send(name=itcast=&amp;age=10); POST需要设置请求头; GET效率更好(应用多); GET大小限制约4K, POST则没有限制; 与 POST 相比, GET 个更简单也更快,并且在大部分情况下都能用。 然而，在以下情况中，使用 POST 请求： 无法使用缓存文件。 向服务器发送大量数据（POST 没有数据量限制） 发送包含位置字符的用户输入时，POST 比 GET 更稳定也更可靠。 案例 HTML &lt;div&gt; &lt;form action=&quot;./page6-data.php&quot; method=&quot;post&quot;&gt; 考号：&lt;input type=&quot;text&quot; name=&quot;code&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt; &lt;/form&gt; &lt;/div&gt; PHP 文件名:page6-data.php &lt;?php / 服务器端渲染页面 arr = array(); arr[&apos;123&apos;] = array(&quot;username&quot;=&gt;&quot;张三&quot;,&quot;chinese&quot;=&gt;&quot;130&quot;,&quot;math&quot;=&gt;&quot;149&quot;,&quot;english&quot;=&gt;&quot;146&quot;,&quot;summary&quot;=&gt;&quot;298&quot;); arr[&apos;124&apos;] = array(&quot;username&quot;=&gt;&quot;李四&quot;,&quot;chinese&quot;=&gt;&quot;100&quot;,&quot;math&quot;=&gt;&quot;140&quot;,&quot;english&quot;=&gt;&quot;136&quot;,&quot;summary&quot;=&gt;&quot;298&quot;); arr[&apos;125&apos;] = array(&quot;username&quot;=&gt;&quot;王五&quot;,&quot;chinese&quot;=&gt;&quot;90&quot;,&quot;math&quot;=&gt;&quot;139&quot;,&quot;english&quot;=&gt;&quot;126&quot;,&quot;summary&quot;=&gt;&quot;298&quot;); arr[&apos;126&apos;] = array(&quot;username&quot;=&gt;&quot;赵六&quot;,&quot;chinese&quot;=&gt;&quot;30&quot;,&quot;math&quot;=&gt;&quot;50&quot;,&quot;english&quot;=&gt;&quot;80&quot;,&quot;summary&quot;=&gt;&quot;100&quot;); code = $_POST[&apos;code&apos;]; f($code == &apos;admin&apos;){ foreach($arr as $value){ echo &quot;&lt;ul&gt; &lt;li&gt;姓名：$value[username]&lt;/li&gt; &lt;li&gt;语文：$value[chinese]&lt;/li&gt; &lt;li&gt;数学：$value[math]&lt;/li&gt; &lt;li&gt;英语：$value[english]&lt;/li&gt; &lt;li&gt;综合：$value[summary]&lt;/li&gt; &lt;/ul&gt;&quot;; } else{ $score = $arr[$code]; echo &quot;&lt;ul&gt; &lt;li&gt;姓名：$score[username]&lt;/li&gt; &lt;li&gt;语文：$score[chinese]&lt;/li&gt; &lt;li&gt;数学：$score[math]&lt;/li&gt; &lt;li&gt;英语：$score[english]&lt;/li&gt; &lt;li&gt;综合：$score[summary]&lt;/li&gt; &lt;/ul&gt;&quot;; } ?&gt; 后台接口 将数组和对象转换为字符串的方法 — json_encode(); 将字符串转换为对象的方式 — json_decod(); 接口说白了就是后台返回特定格式数据, 而不是一个完整的页面, 就是从后台到前台返回一些数据; 请求参数分析 open(); xhr.open(&quot;get&quot;,&quot;nemo.php?username=&quot;+uname+&quot;&amp;password=&quot;+pwd,true); 调用open方法并不会真正发送请求, 而是启动一个请求以备发送. 它接受三个参数: 参数一: 请求方式(get获取数据, post提交数据); 参数二: 请求地址; 参数三: 同步或者异步标识位, 默认是 true, true表示异步, false 表示同步; 注意： 如果是get请求， 那么请求参数必须在url中传递， 那么就用encodeURI（） 进行编码，防止乱码。 send(); 如果要发送请求， 用send()方法。 要发送特定的请求，需要调用send（）方法。它接收一个参数，即要作为请求主体发送的数据。 get请求，则必须传入null。post请求传入字符串。 get请求是只有头部，没有主体的，而post请求有请求主体。 注意：post请求参数通过send传递，不需要通过encodeURI()转码,但是必须需要设置请求参数. 创建 xhr 对象1. 标准: xhr = new XMLHttprequest(); 2. IE6: xhr = newActiveXObject(&apos;Microsoft.XMLHTTP&quot;); xhr 对象有一个重要的属性, 就是 readyState 属性,表示”就绪状态”, 就是 xhr.readyState。 readyState 取值有5种值： 0、1、2、3、4 0 ----- 未初始化。 1 ----- XMLHttpRequest对象正在加载。 2 ----- xmlHttp对象加载完毕。 3 ----- 正在传输数据。 4 ----- 全部完成。 只要 readyState改变后，就会触发一个事件 onreadystatechange 事件. xhr.onreadyStatechange = function(){}; Ajax-但用senp方法发出HTTP请求之后,判断ceadyState得到的时候,就会有一个属性xhr.status表示的是请求的文件的状态码. 1. 1** ----- 消息. 2. 200 ----- 代码请求成功. 3. 3** ----- 重定向. 4. 404 ----- 请求错误. 5. 500 ----- 服务器错误. 6. 6** ----- 其他. 案例 HTML &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function(){ var btn = document.getElementById(&apos;btn&apos;); btn.onclick = function(){ var uname = document.getElementById(&apos;username&apos;).value; var pw = document.getElementById(&apos;password&apos;).value; // 1、创建XMLHttpRequest对象 var xhr = null; if(window.XMLHttpRequest){ xhr = new XMLHttpRequest();//标准 }else{ xhr = new ActiveXObject(&quot;Microsoft&quot;);//IE6 } // 2、准备发送 /* 参数一：请求方式（get获取数据；post提交数据） 参数二：请求地址 参数三：同步或者异步标志位，默认是true表示异步，false表示同步 post请求参数通过send传递，不需要通过encodeURI()转码 必须设置请求头信息 */ var param = &apos;username=&apos;+uname+&apos;&amp;password=&apos;+pw; ------------------------------------------------ get方法: xhr.open(&apos;get&apos;,&apos;03get.php?&apos;+encodeURI(param),true); // 3、执行发送动作 xhr.send(null);//get请求这里需要添加null参数 ------------------------------------------------ post方法: xhr.open(&apos;post&apos;,&apos;04post.php&apos;,false); // 3、执行发送动作 xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(param);//post请求参数在这里传递，并且不需要转码 ------------------------------------------------ // 4、指定回调函数 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ var data = xhr.responseText; var info = document.getElementById(&apos;info&apos;); if(data == &apos;1&apos;){ info.innerHTML = &apos;登录成功&apos;; }else if(data == &apos;2&apos;){ info.innerHTML = &apos;用户名或者密码错误&apos;; } } } } } &lt;/script&gt; &lt;body&gt; &lt;form&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt; &lt;span id=&quot;info&quot;&gt;&lt;/span&gt; &lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; id=&quot;password&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;登录&quot; id=&quot;btn&quot;&gt; &lt;/form&gt; &lt;/body&gt; PHP &lt;?php ---------------------------- $_GET方法: $uname = $_GET[&apos;username&apos;]; $pw = $_GET[&apos;password&apos;]; ---------------------------- $_POST方法: $uname = $_POST[&apos;username&apos;]; $pw = $_POST[&apos;password&apos;]; ---------------------------- if($uname == &apos;admin&apos; &amp;&amp; $pw == &apos;123&apos;){ echo 1; }else{ echo $uname; } ?&gt; XMLXML 数据格式什么是 XML XML 指可扩展的标记语言 主要用来输出和存储数据 设置宗旨是(传输数据)，而非显示数据 XML 标签没有语义化，需要自行定义标签 XML 数据格式的缺点 原数据占用的数据量比较大，不利于大量数据的网络传输 解析不太方便 XML 和 HTML 的区别 XML 是用来传输和存储数据的，而HTML被设计是用来显示数据的 XML 只在传输数据,HTML 只在显示信息 XML 的树结构 XML 文档行程了的也是一种”树结构” XML文档必须包含根元素. 该元素是所有其他元素的父元素, 树结构从根开始,扩展到最低端 XML 的语法 所有 XML 元素都必须是闭合标签 XML 标签大小写明感,因此必须使用相同的大小写来编写打开标签和关闭标签 XML 必须正确的嵌套 XML 文档必须有根元素 XML 的属性值必须加引号 在 XML 中,空格会被保留 JSONjson 数据结构什么是 JSON JavaScript 对象表示法 是存储和交换文本信息的语法 轻量级的文本数据交换格式 JSON 数据和普通数据的 JS 兑现的区别 json 对象没有变量 json 形式的数据结尾没有分号 json 数据中的键必须用双引号包括 JSON 和 XML 对比 JSON 比 XML 更小, 更快, 更易解析 json 数据解析 把 json 文本转换为 JavaScript 对象 JSON 最常见的用法之一, 是从 Web 服务器上读取 JSON 数据(作为文件或作为HttpRequest), 将 JSON 数据转换为 JavaScript 对象, 然后在网页中使用该数据. 为什么要转换 在数据传输过程中, json 是以文本, 即字符串的形式传递的, 而 JS 操作的是 JSON 对象. 所以, JSON 对象和 JSON 字符串之间的相互转换是关键. 转换的方法 JSON_parse(); 把 json 形式的字符串转成对象 JSON_stringify(); 把对象转成字符串 eval() 把字符串解析成 js 代码并执行 JSON 数据接口 json_encode(); 把数组转换成 JSON 形式的字符串 同步与异步 同步 重新加载页面 彼此等待 异步 局部加载页面 各做各的 面试题：为什么JavaScript是单线程的却能让AJAX异步发送和回调请求 JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。 Ajax跨域 什么是跨域 跨域是指从一个域名的网页去请求另一个域名的资源。只要 协议、域名、端口有任何一个的不同，就被当作是跨域。 跨域解决方案 jsonp, document.domain + iframe, location.hash + iframe, window.name + iframe, window.postMessage, flash 等第三方方插件. 大部分都是使用 jsonp. JSONP 原理 静态 script 标签的 src 实现跨域 script标签里面的 async 属性表示异步加载资源, 默认是同步加载. 动态创建 script 标签发出去的请求是异步请求. jQuery 基本使用 ($.ajax)$.ajax({ url: &apos;地址&apos;, type: &apos;请求数据方法 ( get post )&apos;, dataType: &apos;返回的数据类型 (json jsonp )&apos;, data: {后台接受的数据 : 获取某个数据}, jsonpCallback:&apos;为jsonp请求指定一个回调函数名&apos; }) success:function(返回的数据){ 请求成功后的回调函数; };]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue小白学习笔记0--购物车]]></title>
    <url>%2Fvue%E5%B0%8F%E7%99%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00--%E8%B4%AD%E7%89%A9%E8%BD%A6.html</url>
    <content type="text"><![CDATA[第一个实战：写一个购物车实例为了从零开始学习，vue.js文件是用引入的。用两个v-for实现两个商品组 html&lt;div id=&quot;app&quot; v-cloak&gt; &lt;template v-if=&quot;list.length&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; :checked=&quot;checkedAll&quot; @click=&quot;checkAll&quot;&gt; &lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品单价&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;template v-for=&quot;(item,index) in newList&quot;&gt; &lt;tbody :key=&quot;index&quot;&gt; &lt;tr v-for=&quot;(item_child,idx) of item&quot;&gt; &lt;td&gt; &lt;!-- index,idx为参数 --&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; :checked=&quot;item_child.checked&quot; @click=&quot;check(index,idx)&quot;&gt; &lt;/td&gt; &lt;td&gt;{{idx+1}}&lt;/td&gt; &lt;td&gt;{{item_child.name}}&lt;/td&gt; &lt;td&gt;{{item_child.price}}&lt;/td&gt; &lt;td&gt; &lt;button @click=&quot;handleReduce(idx)&quot; :disabled=&quot;item_child.disabled&quot;&gt;-&lt;/button&gt; &lt;span&gt;{{item_child.count}}&lt;/span&gt; &lt;button @click=&quot;handleAdd(idx)&quot;&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=&quot;handleRemove(idx)&quot;&gt;移除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;hr&gt; &lt;/template&gt; &lt;/table&gt; &lt;div&gt;总价：￥ {{totalPrice}} 元&lt;/div&gt; &lt;/template&gt; &lt;div v-else&gt;购物车为空&lt;/div&gt; &lt;/div&gt; 1#### script let app = new Vue({ el: &apos;#app&apos;, data: { checkedAll: true, list: [ [{ id: 1, name: &apos;iPhone 7&apos;, price: 1000, count: 1, checked: true, }, { id: 2, name: &apos;iPad Pro&apos;, price: 2000, count: 1, checked: true, }, { id: 1, name: &apos;MacBook Pro&apos;, price: 3000, count: 1, checked: true, }, ], [{ id: 1, name: &apos;西瓜&apos;, price: 10, count: 1, checked: true, }, { id: 2, name: &apos;冬瓜&apos;, price: 20, count: 1, checked: true, }, { id: 1, name: &apos;南瓜&apos;, price: 30, count: 1, checked: true, }, { id: 1, name: &apos;黄瓜&apos;, price: 30, count: 1, checked: true, }, ] ], }, /* 计算属性 */ computed: { //总价 totalPrice: function () { let total = 0; for (let i = 0; i &lt; this.list.length; i++) { let arr = this.list[i]; for (let n = 0; n &lt; arr.length; n++) { let arr_child = arr[n]; if (arr_child.checked === true) { total += arr_child.price * arr_child.count; } } } // 返回添加千位分隔符的字符串 return total.toString().replace(/\B(?=(\d{3})+$)/g, &apos;,&apos;); }, newList: function () { for (let i = 0; i &lt; this.list.length; i++) { let item = this.list[i]; // console.log(item); for (let n = 0; n &lt; item.length; n++) { let item_list = item[n]; if (item_list.count === 1) { item_list.disabled = true } else { item_list.disabled = false } } } return this.list; }, }, /* 方法 */ methods: { //减少商品数量 handleReduce: function (index) { if (this.list[index].count === 1) { return; } this.list[index].count--; }, //增加商品数量 handleAdd: function (index) { this.list[index].count++ }, //删除商品 handleRemove: function (index) { this.list.splice(index, 1); }, //全选，全不选 checkAll: function () { this.checkedAll = !this.checkedAll; let this_checked; for (let i = 0; i &lt; this.list.length; i++) { let item = this.list[i]; for (let n = 0; n &lt; item.length; n++) { let item_child = item[n]; item_child.checked = this.checkedAll; } } console.log(&apos;全选：&apos;, this.checkedAll, &apos;, this_checked:&apos;, this.checkedAll); }, //选中商品，取消选中 check: function (index, idx) { this.list[index][idx].checked = !this.list[index][idx].checked; for (let i = 0; i &lt; this.list.length; i++) { let item = this.list[i]; for (let n = 0; n &lt; item.length; n++) { let item_child = item[n]; if (item_child.checked === false) { this.checkedAll = false; return } else { this.checkedAll = true; } } } // console.log(&apos;改变后&apos;, this.newList); } }, /*实例已挂载*/ mounted: function () { // console.log(this.newList); } });]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue小白学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程]]></title>
    <url>%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[对象的概念其他语言中，对象的两个概念： 类：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生； 实例：实例是根据类创建的对象，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。 所以，类和实例是大多数面向对象编程语言的基本概念。 javaScript中对象的概念javaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。原型是指我们要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象：1234567var robot = &#123; name: &apos;Robot&apos;, height: 1.6, run: function () &#123; console.log(this.name + &apos; is running...&apos;); &#125;&#125;; 我们看这个robot对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！于是我们把它改名为Student，然后创建出xiaoming:12345678910111213var Student = &#123; name: &apos;Robot&apos;, height: 1.2, run: function () &#123; console.log(this.name + &apos; is running...&apos;); &#125;&#125;;var xiaoming = &#123; name: &apos;小明&apos;&#125;;xiaoming.__proto__ = Student; 注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：12xiaoming.name; // &apos;小明&apos;xiaoming.run(); // 小明 is running... xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用：JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。如果你把xiaoming的原型指向其他对象：1234567var Bird = &#123; fly: function () &#123; console.log(this.name + &apos; is flying...&apos;); &#125;&#125;;xiaoming.__proto__ = Bird; 现在xiaoming已经无法run()了，他已经变成了一只鸟：1xiaoming.fly(); // 小明 is flying... 在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象。 请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming： var Student = {// 原型对象 name: ‘Robot’, height: 1.2, run: function () { console.log(this.name + ‘ is running…’); }}; function createStudent(name) { // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;} var xiaoming = createStudent(‘小明’);xiaoming.run(); // 小明 is running…xiaoming.proto === Student; // true 这是创建原型继承的一种方法 创建对象 JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。其原型链是：1234arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null``` `Array.prototype`定义了`indexOf()`、`shift()`等方法，因此你可以在所有的`Array`对象上直接调用这些方法。 当我们创建一个函数时： function foo() { return 0;}1函数也是一个对象，它的原型链是： foo —-&gt; Function.prototype —-&gt; Object.prototype —-&gt; null1234由于`Function.prototype`定义了`apply()`等方法，因此，所有函数都可以调用`apply()`方法。 &gt; 很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。 ### 构造函数除了直接用`&#123; ... &#125;`创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数： function Student(name) { this.name = name; this.hello = function () { alert(‘Hello, ‘ + this.name + ‘!’); }}12你会问，咦，这不是一个普通函数吗？ 这确实是一个普通函数，但是在JavaScript中，可以用&lt;b&gt;关键字`new`&lt;/b&gt;来调用这个函数，并返回一个对象： var xiaoming = new Student(‘小明’);xiaoming.name; // ‘小明’xiaoming.hello(); // Hello, 小明!123&gt; 注意，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，**如果写了`new`，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。** 新创建的`xiaoming`的原型链是： xiaoming —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null1也就是说，`xiaoming`的原型指向函数`Student`的原型。如果你又创建了`xiaohong`、`xiaojun`，那么这些对象的原型与`xiaoming`是一样的： xiaoming ↘xiaohong -→ Student.prototype —-&gt; Object.prototype —-&gt; nullxiaojun ↗1用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身： xiaoming.constructor === Student.prototype.constructor; // trueStudent.prototype.constructor === Student; // true Object.getPrototypeOf(xiaoming) === Student.prototype; // true xiaoming instanceof Student; // true123456789看晕了吧？用一张图来表示这些乱七八糟的关系就是：![image](https://cdn.liaoxuefeng.com/cdn/files/attachments/00143529922671163eebb527bc14547ac11363bf186557d000/l)`Student`创建了一个原型对象，`Student`通过属性`prototype`指向自身的原型对象，`xiaoming`、`xiaohong`也一样指向这个原型对象。这个原型对象自己有个属性`constructor`，可以指向创建自己的`Student`函数本身。&gt; 红色箭头是原型链。**注意，`Student.prototype`指向的对象就是`xiaoming`、`xiaohong`的原型对象，这个原型对象自己还有个属性`constructor`，指向`Student`函数本身** &gt; 另外，函数`Student`恰好有个属性`prototype`指向`xiaoming`、`xiaohong`的原型对象，但是`xiaoming`、`xiaohong`这些对象可没有prototype这个属性，不过可以用`__proto__`这个非标准用法来查看。 不过还有一个小问题，注意观察： xiaoming.name; // ‘小明’xiaohong.name; // ‘小红’xiaoming.hello; // function: Student.hello()xiaohong.hello; // function: Student.hello()xiaoming.hello === xiaohong.hello; // false123456`xiaoming`和`xiaohong`各自的`name`不同，这是对的，否则我们无法区分谁是谁了。 `xiaoming`和`xiaohong`各自的`hello`是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！ 如果我们通过`new Student()`创建了很多对象，这些对象的`hello`函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 要让创建的对象共享一个`hello`函数，根据对象的属性查找原则，我们只要把`hello`函数移动到`xiaoming`、`xiaohong`这些对象共同的原型上就可以了，也就是`Student.prototype`： ![image](https://cdn.liaoxuefeng.com/cdn/files/attachments/001435299854512faf32868f60348be878982909b5a5d04000/l) 修改代码如下： function Student(name) { this.name = name;} Student.prototype.hello = function () { alert(‘Hello, ‘ + this.name + ‘!’);};123456用`new`创建基于原型的JavaScript的对象就是这么简单！ ### 忘记写new怎么办如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写`new`怎么办？ 在strict模式下，`this.name = name`将报错，因为`this`绑定为`undefined`，在非strict模式下，`this.name = name`不报错，因为`this`绑定为`window`，于是无意间创建了全局变量`name`，并且返回`undefined`，这个结果更糟糕。 所以，调用构造函数千万不要忘记写`new`。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如*jslint*将可以帮你检测到漏写的`new`。 最后，我们还可以编写一个`createStudent()`函数，在内部封装所有的new操作。一个常用的编程模式像这样： function Student(props) { this.name = props.name || ‘匿名’; // 默认值为’匿名’ this.grade = props.grade || 1; // 默认值为1} Student.prototype.hello = function () { alert(‘Hello, ‘ + this.name + ‘!’);}; function createStudent(props) { return new Student(props || {})}12这个`createStudent()`函数有几个巨大的优点：一是不需要`new`来调用，二是参数非常灵活，可以不传，也可以这么传： *props参数传的是对象* var xiaoming = createStudent({ name: ‘小明’}); xiaoming.grade; // 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个**Object**，我们无需记忆参数的顺序。如果恰好从`JSON`拿到了一个对象，就可以直接创建出`xiaoming`。#### 练习请利用构造函数定义`Cat`，并让所有的`Cat`对象有一个`name`属性，并共享一个方法`say()`，返回字符串`&apos;Hello, xxx!&apos;`： &apos;use strict&apos;; function Cat(name)&#123; this.name=name||&apos;匿名&apos;; &#125; Cat.prototype.say=function()&#123; return &apos;Hello, &apos;+this.name+&apos;!&apos;; &#125;&gt; 段落总结：如果创建的对象不可以共享的属性例如`name`要放在`Student`函数本身里,这样每次创建新对象都会通过指向的原型对象去复制函数本身的`name`,虽然相像但不是是同一个东西； 如果是可以共享的属性如`hello`，放在`Student`创建的原型里，每次使用的都是同一个属性。 ## 原型继承在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，**继承实际上是类型的扩展**。但是，**JavaScript**由于采用**原型继承**，我们无法直接扩展一个Class，**因为根本不存在Class这种类型**。 但是办法还是有的。我们先回顾`Student`构造函数： function Student(props) &#123; this.name = props.name || &apos;Unnamed&apos;; &#125; Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;以及`Student`的原型链：![Student的原型链](https://cdn.liaoxuefeng.com/cdn/files/attachments/001439872136313496e60e07ed143bda40a0200b12d8cc3000/l) 现在，我们要基于`Student`扩展出`PrimaryStudent`，可以先定义出`PrimaryStudent`： function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1; &#125;但是，调用了`Student`构造函数不等于继承了`Student`，`PrimaryStudent`创建的对象的原型是： new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null必须想办法把原型链修改为： new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null这样，原型链对了，继承关系就对了。新的基于`PrimaryStudent`创建的对象不但能调用`PrimaryStudent.prototype`定义的方法，也可以调用`Student.prototype`定义的方法。 如果你想用最简单粗暴的方法这么干：PrimaryStudent.prototype = Student.prototype;是不行的！如果这样的话，`PrimaryStudent`和`Student`共享一个原型对象，那还要定义`PrimaryStudent`干啥？我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向`Student.prototype`。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： // PrimaryStudent构造函数: function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1; &#125; // 空函数F: function F() &#123; &#125; // 把F的原型指向Student.prototype: F.prototype = Student.prototype; // 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype: PrimaryStudent.prototype = new F(); // 把PrimaryStudent原型的构造函数修复为PrimaryStudent: PrimaryStudent.prototype.constructor = PrimaryStudent; // 继续在PrimaryStudent原型（就是new F()对象）上定义方法： PrimaryStudent.prototype.getGrade = function () &#123; return this.grade; &#125;; // 创建xiaoming: var xiaoming = new PrimaryStudent(&#123; name: &apos;小明&apos;, grade: 2 &#125;); xiaoming.name; // &apos;小明&apos; xiaoming.grade; // 2 // 验证原型: xiaoming.__proto__ === PrimaryStudent.prototype; // true xiaoming.__proto__.__proto__ === Student.prototype; // true // 验证继承关系: xiaoming instanceof PrimaryStudent; // true xiaoming instanceof Student; // true用一张图来表示新的原型链：![新的原型链](https://cdn.liaoxuefeng.com/cdn/files/attachments/001439872160923ca15925ec79f4692a98404ddb2ed5503000/l)注意，函数`F`仅用于桥接，我们仅创建了一个`new F()`实例，而且，没有改变原有的`Student`定义的原型链。如果把继承这个动作用一个`inherits()`函数封装起来，还可以隐藏`F`的定义，并简化代码： function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; &#125; 这个`inherits()`函数可以复用： function Student(props) &#123; this.name = props.name || &apos;Unnamed&apos;; &#125; Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125; function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1; &#125; // 实现原型继承链: inherits(PrimaryStudent, Student); // 绑定其他方法到PrimaryStudent原型: PrimaryStudent.prototype.getGrade = function () &#123; return this.grade; &#125;;#### 小结JavaScript的原型继承实现方式就是：1. 定义新的构造函数，并在内部用`call()`调用希望“继承”的构造函数，并绑定`this`；2. 借助中间函数F实现原型链继承，最好通过封装的`inherits`函数完成；3. 继续在新的构造函数的原型上定义新方法。## class继承 &gt; 在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。我们先回顾用函数实现`Student`的方法： function Student(name) &#123; this.name = name; &#125; Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;如果用新的`class`关键字来编写`Student`，可以这样写： class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125; &#125;比较一下就可以发现，`class`的定义包含了构造函数`constructor`和定义在原型对象上的函数`hello()`（*注意没有function关键字*），这样就避免了`Student.prototype.hello = function () &#123;...&#125;`这样分散的代码。 最后，创建一个`Student`对象代码和前面章节完全一样： var xiaoming = new Student(‘小明’);xiaoming.hello();` class继承用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert(&apos;I am at grade &apos; + this.grade); } } 注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。 PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。 ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 练习请利用class重新定义Cat，并让它从已有的Animal继承，然后新增一个方法say()，返回字符串&#39;Hello, xxx!&#39;： &apos;use strict&apos;; class Animal { constructor(name) { this.name = name; } } class Cat extends Animal{ constructor(name){ super(name); } say(){ return `Hello, ${this.name}!`; } } 总结无论是ES5还是ES6还都是使用prototype原型继承的方式来模拟其他语言中类和实例的方式来实现原型继承。class只是把代码抽象一下，从语言层面看上去跟其他语言差不多了，背后并没有改变。 不过日常工作没有关系，尽情使用class来实现面向对象编程好了。背后的处理交给工程化工具。 基本照抄廖雪峰老师的文章，插入了一些自己的感想。原文地址]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间的处理]]></title>
    <url>%2F%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[JavaScript中的时间处理Js获取当前日期时间及其它操作1234567891011121314var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 这些方法获取到的是数字，要显示的话要使用.toString()转换成字符串 。 获取当前月份，需要myDate.getMonth() - 1。 定义日期Date 对象用于处理日期和时间。可以通过 new 关键词来定义 Date 对象。以下代码定义了名为 myDate 的 Date 对象：1var myDate=new Date() 注释：Date 对象自动使用当前的日期和时间作为其初始值。 操作日期通过使用针对日期对象的方法，我们可以很容易地对日期进行操作。在下面的例子中，我们为日期对象设置了一个特定的日期 (2008 年 8 月 9 日)：12var myDate=new Date()myDate.setFullYear(2008,7,9) 注意：表示月份的参数介于 0 到 11 之间。也就是说，如果希望把月设置为 8 月，则参数应该是 7。 在下面的例子中，我们将日期对象设置为 5 天后的日期：12var myDate=new Date()myDate.setDate(myDate.getDate()+5) 注意：如果增加天数会改变月份或者年份，那么日期对象会自动完成这种转换。 比较日期（计算年龄）1234567891011let nowDate=new Date();//当前时间let myDate=new Date();myDate.setFullYear(myYear,myMonth-1,myDay);//出生时间let newDate=nowDate.getTime()-myDate.getTime();//时间差（单位：毫秒）// 向下取整 例如 10岁 20天 会计算成 10岁// 如果要向上取整 计算成11岁，把floor替换成 ceilvar age = Math.ceil(newDate / 1000 / 60 / 60 / 24 /365);if (isNaN(age))&#123; age = &quot;&quot;;&#125;return age; 把时间戳转换为日期得到后台从数据库中拿到的数据我们希望格式是 2016年10月25日 17时37分30秒 或者 2016/10/25 17:37:30 然而我们前台得到的却是一段数字（时间戳，毫秒数） 1477386005 我们要将时间戳转化为我们想要的格式。 核心方法 ： 1477386005是我从后台得到时间戳 （注意：有的时候得到的时间戳是已经乘以1000的）123var unixTimestamp = new Date( 1477386005*1000 ) ; //转化时间戳commonTime = unixTimestamp.toLocaleString(); //获得日期alert(commonTime); 1234567/*数字是个位，前面补足0*/function formatTime(num)&#123; if(num&lt;10) return &apos;0&apos;+num else return num+&apos;&apos;&#125; 但是我希望转换为我自己想要的格式，就在本页面重写一下 toLocaleString()方法即可。123456789Date.prototype.toLocaleString = function() &#123; var getFullYear=formatTime(this.getFullYear()); var getMonth=formatTime(this.getMonth() + 1); var getDate=formatTime(this.getDate()); var getHours=formatTime(this.getHours()); var getMinutes=formatTime(this.getMinutes()); var getSeconds=formatTime(this.getSeconds()); return getFullYear + &quot;年&quot; + getMonth + &quot;月&quot; + getDate + &quot;日 &quot; + getHours + &quot;点&quot; + getMinutes + &quot;分&quot; + getSeconds + &quot;秒&quot;; &#125;; 或者用函数实现 const formatTime = date =&gt; { const year = date.getFullYear() const month = date.getMonth() + 1 const day = date.getDate() const hour = date.getHours() const minute = date.getMinutes() const second = date.getSeconds() //.map()返回一个新数组 return [year, month, day].map(formatNumber).join(&apos;/&apos;) + &apos; &apos; + [hour, minute, second].map(formatNumber).join(&apos;:&apos;) } //个位数补零 const formatNumber = n =&gt; { n = n.toString() //判断字符串是否有两个，否则补零 return n[1] ? n : &apos;0&apos; + n } 计时器123456789101112131415161718192021222324252627282930313233343536373839404142var t;var seconds;/*计时器*/function timing()&#123; seconds = 0; if (seconds &gt; 21599) &#123; let time = &apos;6小时，不想继续了gg&apos; return; &#125; t = setTimeout(function()&#123; seconds=seconds+1; timing(); &#125;,1000); formatSeconds(seconds);&#125;/*输出计时文字*/function formatSeconds(seconds)&#123; var mins=0,hours=0,time=&apos;&apos;; if(seconds&lt;3600)&#123; mins = parseInt(seconds /60) seconds=seconds%60 &#125;else&#123; mins=parseInt(seconds/60) seconds=seconds%60 hours=parseInt(mins/60) mins=mins%60 &#125; time=formatTime(hours)+&apos;:&apos;+formatTime(mins)+&apos;:&apos;+formatTime(seconds); return time;&#125;/*数字是个位，前面补足0*/function formatTime(num)&#123; if(num&lt;10) return &apos;0&apos;+num else return num+&apos;&apos;&#125;/* 停止计时 */function stopCount()&#123; clearTimeout(t); console.log(&apos;结束游戏，游戏时长为：&apos;,seconds,&apos;秒&apos;);&#125; 倒计时（目前能用，还需改进）123456789101112131415161718192021222324252627282930/*数字是个位，前面补足0*/function formatTime(num)&#123; if(num&lt;10) return &apos;0&apos;+num else return num+&apos;&apos;&#125;var lastSeconds=$(&apos;#seconds&apos;).val();//获取到结束日期（这里单位是秒）var timeAdd=0;var interval=1000;function leftTimer()&#123; timeAdd=timeAdd+1; var leftTime=lastSeconds - timeAdd;//减少后的时间 if(leftTime&gt;=0)&#123; var days=parseInt(leftTime/60/60/24,10);//天 var hours=parseInt(leftTime/60/60%24,10);//小时 var minutes =parseInt(leftTime/60%60,10);//分钟 var seconds =parseInt(leftTime%60,10);//秒 days = formatTime(days); hours = formatTime(hours); minutes = formatTime(minutes); seconds = formatTime(seconds); $(&apos;#timer&apos;).text(days+&quot;天&quot; + hours+&quot;小时&quot; + minutes+&quot;分&quot;+seconds+&quot;秒&quot;); &#125;else&#123; //如果时间到期，do something... $(&apos;#btn-refund&apos;).attr(&apos;disabled&apos;,&quot;true&quot;).css(&#123;&apos;pointer-events&apos;:&apos;none&apos;,&apos;background-color&apos;:&apos;#dddddd&apos;&#125;);//添加disabled属性，禁用按钮 return false; &#125;&#125;window.setInterval(function()&#123;leftTimer();&#125;, interval);]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决软键盘弹窗 fixed失效问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E7%AA%97%20fixed%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[概述 这个问题常出现在移动web开发中聊天或者留言页面的绝对定位输入框上，页面超过屏幕大小时候输入框focus状态下（键盘弹出）绝对定位的元素失效，导致页面滚动时候把定位元素一并带走，体验十分不好，在此留下一自己的方法，让更多的人不需要再爬这样的小坑。 解决办法原理很简单，就是定义一个外框把页面包起来，把需要使用fixed定位的元素设置成absolute定位，然后设置外框元素的样式即可，下面是实例：假设外框元素为.wrap，需要fixed定位的元素为.position： DOM1234567&lt;html&gt; &lt;body class=&quot;wrap&quot;&gt; &lt;div class=&quot;position&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;js-searchKey&quot; class=&quot;search-input&quot; placeholder=&quot;关键词搜索&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS12345678910111213141516body.full-body&#123; position: fixed !important; top: 0 !important; right: 0 !important; bottom: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; padding: 0 !important; margin: 0 !important; overflow: hidden !important; -webkit-overflow-scrolling: touch;&#125;.fixed-bug&#123; position: absolute !important;&#125; JS 当input获取焦点，弹出软键盘的时候，就切添加解决bug的class；反之，删除解决bug的class。12345678910111213141516function addBodyClass(element)&#123; $(&apos;body&apos;).addClass(&apos;full-body&apos;); $(element).addClass(&apos;fixed-bug&apos;);&#125;function removeBodyClass(element)&#123; $(&apos;body&apos;).removeClass(&apos;full-body&apos;); $(element).removeClass(&apos;fixed-bug&apos;);&#125;$(&quot;#js-searchKey&quot;).on(&apos;focus&apos;,function()&#123; var $fixed=$(&apos;.position&apos;); addBodyClass($fixed);&#125;);$(&quot;#js-searchKey&quot;).on(&apos;blur&apos;,function()&#123; var $fixed=$(&apos;.position&apos;); removeBodyClass($fixed);&#125;);]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单验证（输入完成，手机号，金额）]]></title>
    <url>%2F%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%EF%BC%88%E8%BE%93%E5%85%A5%E5%AE%8C%E6%88%90%EF%BC%8C%E6%89%8B%E6%9C%BA%E5%8F%B7%EF%BC%8C%E9%87%91%E9%A2%9D%EF%BC%89.html</url>
    <content type="text"><![CDATA[基础函数 金额验证123456789101112131415// 正小数，小数点后两位，数值最前不能有0。//&apos;(\.[0-9]&#123;1,2&#125;)?$)&apos;修改其中的&apos;2&apos;，可以改变小数点后位数的验证var reg = /(^[1-9]([0-9]+)?(\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\.[0-9]([0-9])?$)/;var money = &quot;520.100&quot;;console.log(reg.test(money));//true//000 错//0 对//0. 错//0.0 对//050 错//00050.12错//70.1 对//70.11 对//70.111错//500 正确 金额数值保留两位小数，一位自动补零 123456789101112131415161718//round() 方法可把一个数字舍入为最接近的整数：//parseFloat() 函数可解析一个字符串，并返回一个浮点数。 function returnFloat(value) &#123; var value = Math.round(parseFloat(value) * 100) / 100;//舍入为小数点后两位 var xsd = value.toString().split(&quot;.&quot;);//分割成数组 //小数点后没有值，就添加&apos;.00&apos; if (xsd.length == 1) &#123; value = value.toString() + &quot;.00&quot;; return value; &#125; //小数点后只有1位，就添加&apos;0&apos; if (xsd.length &gt; 1) &#123; if (xsd[1].length &lt; 2) &#123; value = value.toString() + &quot;0&quot;; &#125; return value; &#125; &#125; 手机号码验证 12345678910//验证phoneNum,正确返回true,错误返回falsefunction checkMobile(phoneNum) &#123; var reg_phone = /^[1][0-9][0-9]&#123;9&#125;$/; var regPhone = new RegExp(reg_phone); if (regPhone.test(phoneNum)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 发送验证码，倒计时 123456789101112131415161718192021222324/*发送验证码倒计时*/var countdown = 60;//倒计时为60秒function settime(obj) &#123;//obj为获取验证码按钮 if (countdown == 0) &#123;//如果倒计时为0,重置倒计时为60秒，恢复按钮功能和文字 // obj.attr(&apos;disabled&apos;,false); obj.removeAttr(&quot;disabled&quot;).removeClass(&apos;weui-btn_disabled&apos;).text(&quot;获取验证码&quot;); countdown = 60; return; &#125; else &#123;//如果倒计时不为0,禁用按钮，显示倒计时，倒计时自减1 obj.attr(&apos;disabled&apos;, true).addClass(&apos;weui-btn_disabled&apos;).text(&quot;重新发送(&quot; + countdown + &quot;)&quot;); countdown--; &#125; // 每1000毫秒执行一次settime(obj) setTimeout(function () &#123; settime(obj); &#125;, 1000);&#125;$(&quot;.js-btn-get-code&quot;).on(&apos;click&apos;, function () &#123; var $btn = $(this); var tel_val=$(&quot;#mobile&quot;).val(); if(checkMobile(tel_val)===true)&#123; settime($btn); &#125;&#125;); 判断输入完成 每次输入都进行判断，（可用于验证成功时，执行其他函数，比如给成功提示，或者改变状态） 因为正则的关系且是每次输入完成就验证，导致输入到小数点’.’的时候就会报错。（解决办法是修改正则，可惜本人正则方面的知识很捉急） 12345678910111213141516171819202122232425//.bind(&apos;input propertychange&apos;,function()&#123;//do something&#125;)//每次输入完成后执行do something$(&quot;#moneyCustom&quot;).bind(&apos;input propertychange&apos;, function () &#123; var moneyCustom = $(this).val(); var moneyCustom_end = returnFloat(moneyCustom); console.log(moneyCustom); if (moneyCustom) &#123; var reg = /(^[1-9]([0-9]+)?(\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\.[0-9]([0-9])?$)/; if (!reg.test(moneyCustom)) &#123; $.alert(&#123; title: &apos;提示信息&apos;, text: &apos;赞赏金额的输入格式不正确,请确认!&apos; &#125;); $(this).val(&quot;&quot;); $(&quot;#moneyTotal&quot;).val(&quot;0.00&quot;); changeNum(); return; &#125; $(&quot;#moneyTotal&quot;).val(moneyCustom_end); //金额的正则表达式验证 &#125; else &#123; $(&quot;#moneyTotal&quot;).val(&quot;0.00&quot;); &#125; $(&quot;.js-reward-list&quot;).find(&quot;li.active&quot;).removeClass(&quot;active&quot;).end().find(&quot;.iconfont&quot;).remove(); changeNum(); &#125;); 输入后延迟一段时间进行验证 假设用户输入完成后，一段时间没操作，就判断为输入完成 12345678910111213141516171819202122232425262728293031var queue; $(&quot;#moneyCustom&quot;).on(&apos;keyup&apos;, function (e) &#123; var $this=$(this); clearTimeout(queue); //键盘输入离开后，1000毫秒后执行 queue = setTimeout(function () &#123; var moneyCustom = $this.val(); var moneyCustom_end = returnFloat(moneyCustom); console.log(moneyCustom); if (moneyCustom) &#123; var reg = /(^[1-9]([0-9]+)?(\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\.[0-9]([0-9])?$)/; //金额的正则表达式验证 if (!reg.test(moneyCustom)) &#123; $.alert(&#123; title: &apos;提示信息&apos;, text: &apos;打赏金额只能保留小数点后两位哦~&apos; &#125;); $this.val(&quot;&quot;); $(&quot;#moneyTotal&quot;).val(&quot;0.00&quot;); changeNum(); return; &#125; $(&quot;#moneyTotal&quot;).val(moneyCustom_end); &#125; else &#123; $(&quot;#moneyTotal&quot;).val(&quot;0.00&quot;); &#125; $(&quot;.js-reward-list&quot;).find(&quot;li.active&quot;).removeClass(&quot;active&quot;).end().find(&quot;.iconfont&quot;).remove(); changeNum(); &#125;, 1000); &#125;);]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发环境搭建]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[代码运行环境安装 NodeJs 利用nvm安装和在多个Node.js版本之间切换npm更换源与yarn类似$ npm install -g cnpm --registry=https://registry.npm.taobao.org //下载cnpm$ npm config set registry https://registry.npm.taobao.org Ruby 下载Ruby安装包，官网地址,在安装的时候，请勾选Add Ruby executables to your PATH这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到ruby RubyGems 镜像- Ruby China更换Ruby下载源$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ //删除默认源，添加镜像源$ gem sources -l //显示更换后的下载源https://gems.ruby-china.org# 确保只有 gems.ruby-china.org 安装Sass的gem，gem install sass 开发软件下载安装 WebStorm 前端主要开发IDE，功能齐全，但是需要验证码。注册码获取网址1注册码获取网址2 Visual Studio Code 前端次要开发编辑器，拥有很多好用插件，可以当一个很不错的编辑器使用 yarn npm的替代品，操作的指令更加简单，可以使用安装包进行安装，不过安装包经常下载失败。 安装包下载：链接地址 密码：drtf （失败则使用步骤2） npm下载cnpm，然后用cnpm下载yarn。 cnpm install yarn -g//安装yarn yarn更换下载源 yarn config get registry // 查看下载源yarn config set registry https://registry.npm.taobao.org //更换为淘宝源 Git 代码版本控制软件，可使用命令符进行控制。也可以加装SourceTree（git的图形界面版）SourceTree 安装之后需要使用账号登陆以授权，因为墙的原因，无法登陆。这里记录一下跳过这个初始化的步骤。 安装之后，转到用户本地文件夹下的 SourceTree 目录，没有则新建%LocalAppData%\Atlassian\SourceTree\ 新建 accounts.json 文件%LocalAppData%\Atlassian\SourceTree\accounts.json 输入以下内容保存即可[{&quot;$id&quot;: &quot;1&quot;,&quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;,&quot;Authenticate&quot;: true,&quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot;},&quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot;&quot;, &quot;Email&quot;: null},&quot;IsDefault&quot;: false}] 现在再打开 SourceTree，直接显示主窗口了 git中配置autocrlf来正确处理crlf，防止发生报错。$ git config --global core.autocrlf trueGit可以在你提交时自动地把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用core.autocrlf来打开此项功能，如果是在Windows系统上，把它设置成true，这样当签出代码时，LF会被转换成CRLF 微信开发者工具 适用于微信公众号网页开发，微信小程序开发 搭建项目 项目配置文件 密码：2dxp 项目结构 project/ ├── dist/（生产环境代码） ├── docs/（开发文档） ├── src/（开发环境代码）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── asset/（开发环境代码）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── sass/（scss文件，需要用sass转换）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── js/（js文件，可能是es6格式，需要babel转换）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── images/（图片，需要进行压缩）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── plugins/（第三方插件）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── .html（html页面，需压缩）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── .gitignore（git忽略文件配置）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── gulpfile.js（gulp任务文件）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── package.json（node依赖包配置文件）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── yarn.lock（node依赖包关系文件） 建立版本控制 创建SSH key在户主目录下（C:/users/电脑名/.ssh/id_rsa），里面有id_rsa（私钥，不可泄露），id_rsa.pub（公钥，可以告诉任何人） 如没有，则用Git Bash创建$ ssh-keygen -t rsa -C &quot;xuqipeter@qq.com&quot;然后一路回车，使用默认值即可 登陆GtiHub=&gt;Accout Settings=&gt;SSH Keys页面=&gt;点Add SSH Key=&gt;填上任意Title，在key文本框里粘贴id-rsa.pub的内容 在码云或者GitHub创建仓库（公司可以用码云，私人可以用GitHub） 设置本地仓库，并创建版本。$ git config --global user.name &quot;xuqipeter&quot; //全局设置用户名字$ git config user.email &quot;xuqipeter@qq.com&quot; //全局设置用户邮箱$ git init //建立本地仓库$ git add -A //添加全部文件$ git commit -m &quot;提交的相关说明&quot; //创建本地仓库版本 添加远程仓库&nbsp;&nbsp;教程点击这里$ git remote add origin git@github.com:/github用户名/learngit.git //远程仓库名字默认为origin$ git fetch origin master:tmp //拉取远程master分支,命名为tmp分支$ git diff tmp //比较本地的master分支和远程的origin/master分支的差别$ git branch -a //查看所有分支$ git merge tmp ($ git merge origin/master) //合并远程分支,pull=fetch+merge git 在pull或者合并分支的时候有时会遇到这个界面。可以不管(直接下面3,4步)，如果要输入解释的话就需要:1.按键盘字母 i 进入insert模式2.修改最上面那行黄色合并信息,可以不修改3.按键盘左上角&quot;Esc&quot;4.输入&quot;:wq&quot;,注意是冒号+wq,按回车键即可$ git push -u origin master //把本地内容推送到远程库上$ git branch -d tmp //删除无用分支pull：本地&lt;=远程push：本地=&gt;远程 从远程库克隆git clone git@github.com:/github用户名/learngit.git 安装依赖包 使用yarn安装依赖包（node_modules文件夹）$ yarn init$ yarn install 可能遇到的问题，请百度解决。 创建生产环境代码 使用gulp（在webstorm中设置node环境为6.x.x版本）因为gulp已经开始过时，所以不再继续更新gulpfile.js，以后会替换为webpack 在html中的css和js链接末尾添加?rev=@@hash，自动生成版本号 css和js文件合并（build:js asset/js/p-cruise-line.js是合并后的文件路径）&lt;!-- build:js asset/js/p-cruise-line.js?rev=@@hash --&gt; 这里放要合并的文件&lt;!-- endbuild --&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
